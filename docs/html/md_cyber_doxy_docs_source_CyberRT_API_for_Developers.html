<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cyber-Cmake: Cyber RT API tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cyber-Cmake
   &#160;<span id="projectnumber">8.0</span>
   </div>
   <div id="projectbrief">Pure Cmake Project For Apollo Cyber Rt</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cyber RT API tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document provides an extensive technical deep dive into how to create, manipulate and use Cyber RT's API.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Table of Contents</h1>
<ul>
<li><a href="#Talker-Listener">Talker-Listener</a></li>
<li><a href="#Service-Creation-and-Use">Service Creation and Use</a></li>
<li><a href="#Param-parameter-service">Param parameter service</a></li>
<li><a href="#LOG-API">Log API</a></li>
<li><a href="#Building-a-module-based-on-Component">Building a module based on Component</a></li>
<li><a href="#Launch">Launch</a></li>
<li><a href="#timer">Timer</a></li>
<li><a href="#use-of-time">Time API</a></li>
<li><a href="#Record-file-Read-and-Write">Record file: Read and Write</a></li>
<li><a href="##API-Directory">C++ API Directory</a><ul>
<li><a href="#node-api">Node</a></li>
<li><a href="#writer-api">Writer</a></li>
<li><a href="#client-api">Client</a></li>
<li><a href="#parameter-api">Parameter</a></li>
<li><a href="#timer-api">Timer</a></li>
<li><a href="#timer-api">Time</a></li>
<li><a href="#duration-api">Duration</a></li>
<li><a href="#rate-api">Rate</a></li>
<li><a href="#recordreader-api">RecordReader</a></li>
<li><a href="#recordwriter-api">RecordWriter</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Talker-Listener</h1>
<p>The first part of demonstrating CyberRT API is to understand the Talker/Listener example. Following are three essential concepts: node (basic unit), reader(facility to read message) and writer(facility to write message) of the example.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Create a node</h2>
<p>In the CyberRT framework, the node is the most fundamental unit, similar to the role of a <code>handle</code>. When creating a specific functional object (writer, reader, etc.), you need to create it based on an existing node instance. The node creation interface is as follows:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Node&gt; apollo::cyber::CreateNode(<span class="keyword">const</span> std::string&amp; node_name, <span class="keyword">const</span> std::string&amp; name_space = <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><ul>
<li><p class="startli">Parameters:</p><ul>
<li>node_name: name of the node, globally unique identifier</li>
<li>name_space: name of the space where the node is located</li>
</ul>
<p class="startli">&gt; name_space is empty by default. It is the name of the space concatenated with node_name. The format is <code>/namespace/node_name</code></p>
</li>
<li>Return value - An exclusive smart pointer to Node</li>
<li>Error Conditions - when <code>cyber::Init()</code> has not called, the system is in an uninitialized state, unable to create a node, return nullptr</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Create a writer</h2>
<p>The writer is the basic facility used in CyberRT to send messages. Every writer corresponds to a channel with a specific data type. The writer is created by the <code>CreateWriter</code> interface in the node class. The interfaces are listed as below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line">   <span class="keyword">auto</span> CreateWriter(<span class="keyword">const</span> std::string&amp; channel_name)</div>
<div class="line">       -&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line">   <span class="keyword">auto</span> CreateWriter(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr)</div>
<div class="line">       -&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;;</div>
</div><!-- fragment --><ul>
<li>Parameters:<ul>
<li>channel_name: the name of the channel to write to</li>
<li>MessageT: The type of message to be written out</li>
</ul>
</li>
<li>Return value - Shared pointer to the Writer object</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Create a reader</h2>
<p>The reader is the basic facility used in cyber to receive messages. Reader has to be bound to a callback function when it is created. When a new message arrives in the channel, the callback will be called. The reader is created by the <code>CreateReader</code> interface of the node class. The interfaces are listed as below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> std::string&amp; channel_name, <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::shared_ptr&lt;MessageT&gt;&amp;)&gt;&amp; reader_func)</div>
<div class="line">    -&gt; std::shared_ptr&lt;Reader&lt;MessageT&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> ReaderConfig&amp; config,</div>
<div class="line">                  <span class="keyword">const</span> CallbackFunc&lt;MessageT&gt;&amp; reader_func = <span class="keyword">nullptr</span>)</div>
<div class="line">    -&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr,</div>
<div class="line">                  <span class="keyword">const</span> CallbackFunc&lt;MessageT&gt;&amp; reader_func = <span class="keyword">nullptr</span>)</div>
<div class="line">-&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;;</div>
</div><!-- fragment --><ul>
<li>Parameters:<ul>
<li>MessageT: The type of message to read</li>
<li>channel_name: the name of the channel to receive from</li>
<li>reader_func: callback function to process the messages</li>
</ul>
</li>
<li>Return value - Shared pointer to the Reader object</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Code Example</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
Talker (cyber/examples/talker.cc)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/proto/chatter.pb.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/time/rate.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/time/time.h&quot;</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Rate.html">apollo::cyber::Rate</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Time.html">apollo::cyber::Time</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1proto_1_1Chatter.html">apollo::cyber::proto::Chatter</a>;</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// init cyber framework</span></div>
<div class="line">  apollo::cyber::Init(argv[0]);</div>
<div class="line">  <span class="comment">// create talker node</span></div>
<div class="line">  std::shared_ptr&lt;apollo::cyber::Node&gt; talker_node(</div>
<div class="line">      apollo::cyber::CreateNode(<span class="stringliteral">&quot;talker&quot;</span>));</div>
<div class="line">  <span class="comment">// create talker</span></div>
<div class="line">  <span class="keyword">auto</span> talker = talker_node-&gt;CreateWriter&lt;Chatter&gt;(<span class="stringliteral">&quot;channel/chatter&quot;</span>);</div>
<div class="line">  Rate rate(1.0);</div>
<div class="line">  <span class="keywordflow">while</span> (apollo::cyber::OK()) {</div>
<div class="line">    <span class="keyword">static</span> uint64_t seq = 0;</div>
<div class="line">    <span class="keyword">auto</span> msg = std::make_shared&lt;apollo::cyber::proto::Chatter&gt;();</div>
<div class="line">    msg-&gt;set_timestamp(Time::Now().ToNanosecond());</div>
<div class="line">    msg-&gt;set_lidar_timestamp(Time::Now().ToNanosecond());</div>
<div class="line">    msg-&gt;set_seq(seq++);</div>
<div class="line">    msg-&gt;set_content(<span class="stringliteral">&quot;Hello, apollo!&quot;</span>);</div>
<div class="line">    talker-&gt;Write(msg);</div>
<div class="line">    AINFO &lt;&lt; <span class="stringliteral">&quot;talker sent a message!&quot;</span>;</div>
<div class="line">    rate.Sleep();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1Rate_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1Rate.html">apollo::cyber::Rate</a></div><div class="ttdef"><b>Definition:</b> rate.h:26</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1Time_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1Time.html">apollo::cyber::Time</a></div><div class="ttdoc">Cyber has builtin time type Time.</div><div class="ttdef"><b>Definition:</b> time.h:31</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1proto_1_1Chatter_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1proto_1_1Chatter.html">apollo::cyber::proto::Chatter</a></div><div class="ttdef"><b>Definition:</b> unit_test.pb.h:266</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
Listener (cyber/examples/listener.cc)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/proto/chatter.pb.h&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> MessageCallback(</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;apollo::cyber::proto::Chatter&gt;&amp; msg) {</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;Received message seq-&gt; &quot;</span> &lt;&lt; msg-&gt;seq();</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;msgcontent-&gt;&quot;</span> &lt;&lt; msg-&gt;content();</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// init cyber framework</span></div>
<div class="line">  apollo::cyber::Init(argv[0]);</div>
<div class="line">  <span class="comment">// create listener node</span></div>
<div class="line">  <span class="keyword">auto</span> listener_node = apollo::cyber::CreateNode(<span class="stringliteral">&quot;listener&quot;</span>);</div>
<div class="line">  <span class="comment">// create listener</span></div>
<div class="line">  <span class="keyword">auto</span> listener =</div>
<div class="line">      listener_node-&gt;CreateReader&lt;<a class="code" href="classapollo_1_1cyber_1_1proto_1_1Chatter.html">apollo::cyber::proto::Chatter</a>&gt;(</div>
<div class="line">          <span class="stringliteral">&quot;channel/chatter&quot;</span>, MessageCallback);</div>
<div class="line">  apollo::cyber::WaitForShutdown();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Bazel BUILD file(cyber/samples/BUILD)</h3>
<div class="fragment"><div class="line">cc_binary(</div>
<div class="line">    name = &quot;talker&quot;,</div>
<div class="line">    srcs = [ &quot;talker.cc&quot;, ],</div>
<div class="line">    deps = [</div>
<div class="line">        &quot;//cyber&quot;,</div>
<div class="line">        &quot;//cyber/examples/proto:examples_cc_proto&quot;,</div>
<div class="line">    ],</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">cc_binary(</div>
<div class="line">    name = &quot;listener&quot;,</div>
<div class="line">    srcs = [ &quot;listener.cc&quot;, ],</div>
<div class="line">    deps = [</div>
<div class="line">        &quot;//cyber&quot;,</div>
<div class="line">        &quot;//cyber/examples/proto:examples_cc_proto&quot;,</div>
<div class="line">    ],</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Build and Run</h3>
<ul>
<li>Build: bazel build cyber/examples/…</li>
<li>Run talker/listener in different terminals:<ul>
<li>./bazel-bin/cyber/examples/talker</li>
<li>./bazel-bin/cyber/examples/listener</li>
</ul>
</li>
<li>Examine the results: you should see message printing out on listener.</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Service Creation and Use</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Introduction</h2>
<p>In an autonomous driving system, there are many scenarios that require more from module communication than just sending or receiving messages. Service is another way of communication between nodes. Unlike channel, service implements <code>two-way</code> communication, e.g. a node obtains a response by sending a request. This section introduces the <code>service</code> module in CyberRT API with examples.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Demo - Example</h2>
<p>Problem: create a client-server model that pass Driver.proto back and forth. When a request is sent in by the client, the server parses/processes the request and returns the response.</p>
<p>The implementation of the demo mainly includes the following steps.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Define request and response messages</h3>
<p>All messages in cyber are in the <code>protobuf</code> format. Any protobuf message with serialize/deserialize interfaces can be used as the service request and response message. <code>Driver</code> in examples.proto is used as service request and response in this example:</p>
<div class="fragment"><div class="line">// filename: examples.proto</div>
<div class="line">syntax = &quot;proto2&quot;;</div>
<div class="line">package apollo.cyber.examples.proto;</div>
<div class="line">message Driver {</div>
<div class="line">    optional string content = 1;</div>
<div class="line">    optional uint64 msg_id = 2;</div>
<div class="line">    optional uint64 timestamp = 3;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
Create a service and a client</h3>
<div class="fragment"><div class="line"><span class="comment">// filename: cyber/examples/service.cc</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/examples/proto/examples.pb.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1examples_1_1proto_1_1Driver.html">apollo::cyber::examples::proto::Driver</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  apollo::cyber::Init(argv[0]);</div>
<div class="line">  std::shared_ptr&lt;apollo::cyber::Node&gt; node(</div>
<div class="line">      apollo::cyber::CreateNode(<span class="stringliteral">&quot;start_node&quot;</span>));</div>
<div class="line">  <span class="keyword">auto</span> server = node-&gt;CreateService&lt;Driver, Driver&gt;(</div>
<div class="line">      <span class="stringliteral">&quot;test_server&quot;</span>, [](<span class="keyword">const</span> std::shared_ptr&lt;Driver&gt;&amp; request,</div>
<div class="line">                        std::shared_ptr&lt;Driver&gt;&amp; response) {</div>
<div class="line">        AINFO &lt;&lt; <span class="stringliteral">&quot;server: I am driver server&quot;</span>;</div>
<div class="line">        <span class="keyword">static</span> uint64_t <span class="keywordtype">id</span> = 0;</div>
<div class="line">        ++id;</div>
<div class="line">        response-&gt;set_msg_id(<span class="keywordtype">id</span>);</div>
<div class="line">        response-&gt;set_timestamp(0);</div>
<div class="line">      });</div>
<div class="line">  <span class="keyword">auto</span> client = node-&gt;CreateClient&lt;Driver, Driver&gt;(<span class="stringliteral">&quot;test_server&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> driver_msg = std::make_shared&lt;Driver&gt;();</div>
<div class="line">  driver_msg-&gt;set_msg_id(0);</div>
<div class="line">  driver_msg-&gt;set_timestamp(0);</div>
<div class="line">  <span class="keywordflow">while</span> (apollo::cyber::OK()) {</div>
<div class="line">    <span class="keyword">auto</span> res = client-&gt;SendRequest(driver_msg);</div>
<div class="line">    <span class="keywordflow">if</span> (res != <span class="keyword">nullptr</span>) {</div>
<div class="line">      AINFO &lt;&lt; <span class="stringliteral">&quot;client: response: &quot;</span> &lt;&lt; res-&gt;ShortDebugString();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      AINFO &lt;&lt; <span class="stringliteral">&quot;client: service may not ready.&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    sleep(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  apollo::cyber::WaitForShutdown();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1examples_1_1proto_1_1Driver_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1examples_1_1proto_1_1Driver.html">apollo::cyber::examples::proto::Driver</a></div><div class="ttdef"><b>Definition:</b> examples.pb.h:477</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Bazel build file</h3>
<div class="fragment"><div class="line">cc_binary(</div>
<div class="line">    name = &quot;service&quot;,</div>
<div class="line">    srcs = [ &quot;service.cc&quot;, ],</div>
<div class="line">    deps = [</div>
<div class="line">        &quot;//cyber&quot;,</div>
<div class="line">        &quot;//cyber/examples/proto:examples_cc_proto&quot;,</div>
<div class="line">    ],</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Build and run</h3>
<ul>
<li>Build service/client: bazel build cyber/examples/…</li>
<li>Run: ./bazel-bin/cyber/examples/service</li>
<li>Examining result: you should see content below in apollo/data/log/service.INFO</li>
</ul>
<div class="fragment"><div class="line">I1124 16:36:44.568845 14965 service.cc:30] [service] server: i am driver server</div>
<div class="line">I1124 16:36:44.569031 14949 service.cc:43] [service] client: response: msg_id: 1 timestamp: 0</div>
<div class="line">I1124 16:36:45.569514 14966 service.cc:30] [service] server: i am driver server</div>
<div class="line">I1124 16:36:45.569932 14949 service.cc:43] [service] client: response: msg_id: 2 timestamp: 0</div>
<div class="line">I1124 16:36:46.570627 14967 service.cc:30] [service] server: i am driver server</div>
<div class="line">I1124 16:36:46.571024 14949 service.cc:43] [service] client: response: msg_id: 3 timestamp: 0</div>
<div class="line">I1124 16:36:47.571566 14968 service.cc:30] [service] server: i am driver server</div>
<div class="line">I1124 16:36:47.571962 14949 service.cc:43] [service] client: response: msg_id: 4 timestamp: 0</div>
<div class="line">I1124 16:36:48.572634 14969 service.cc:30] [service] server: i am driver server</div>
<div class="line">I1124 16:36:48.573030 14949 service.cc:43] [service] client: response: msg_id: 5 timestamp: 0</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Precautions</h2>
<ul>
<li>When registering a service, note that duplicate service names are not allowed</li>
<li>The node name applied when registering the server and client should not be duplicated either</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
Parameter Service</h1>
<p>The Parameter Service is used for shared data between nodes, and provides basic operations such as <code>set</code>, <code>get</code>, and <code>list</code>. The Parameter Service is based on the <code>Service</code> implementation and contains service and client.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Parameter Object</h2>
<h3><a class="anchor" id="autotoc_md20"></a>
Supported Data types</h3>
<p>All parameters passed through cyber are <code><a class="el" href="classapollo_1_1cyber_1_1Parameter.html" title="A Parameter holds an apollo::cyber::proto::Param, It&#39;s more human-readable, you can use basic-value t...">apollo::cyber::Parameter</a></code> objects, the table below lists the 5 supported parameter types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter type   </th><th class="markdownTableHeadLeft">C++ data type   </th><th class="markdownTableHeadLeft">protobuf data type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::INT   </td><td class="markdownTableBodyLeft">int64_t   </td><td class="markdownTableBodyLeft">int64    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::DOUBLE   </td><td class="markdownTableBodyLeft">double   </td><td class="markdownTableBodyLeft">double    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::BOOL   </td><td class="markdownTableBodyLeft">bool   </td><td class="markdownTableBodyLeft">bool    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::STRING   </td><td class="markdownTableBodyLeft">std::string   </td><td class="markdownTableBodyLeft">string    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::PROTOBUF   </td><td class="markdownTableBodyLeft">std::string   </td><td class="markdownTableBodyLeft">string    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">apollo::cyber::proto::ParamType::NOT_SET   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">-   </td></tr>
</table>
<p>Besides the 5 types above, Parameter also supports interface with protobuf object as incoming parameter. Post performing serialization processes the object and converts it to the STRING type for transfer.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Creating the Parameter Object</h3>
<p>Supported constructors:</p>
<div class="fragment"><div class="line">Parameter();  <span class="comment">// Name is empty, type is NOT_SET</span></div>
<div class="line"><span class="keyword">explicit</span> Parameter(<span class="keyword">const</span> Parameter&amp; parameter);</div>
<div class="line"><span class="keyword">explicit</span> Parameter(<span class="keyword">const</span> std::string&amp; name);  <span class="comment">// type为NOT_SET</span></div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">bool</span> bool_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">int</span> int_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> int64_t int_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">float</span> double_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">double</span> double_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; string_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">char</span>* string_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; msg_str,</div>
<div class="line">          <span class="keyword">const</span> std::string&amp; full_name, <span class="keyword">const</span> std::string&amp; proto_desc);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> google::protobuf::Message&amp; msg);</div>
</div><!-- fragment --><p>Sample code of using Parameter object:</p>
<div class="fragment"><div class="line">Parameter a(<span class="stringliteral">&quot;int&quot;</span>, 10);</div>
<div class="line">Parameter b(<span class="stringliteral">&quot;bool&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">Parameter c(<span class="stringliteral">&quot;double&quot;</span>, 0.1);</div>
<div class="line">Parameter d(<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;cyber&quot;</span>);</div>
<div class="line">Parameter e(<span class="stringliteral">&quot;string&quot;</span>, std::string(<span class="stringliteral">&quot;cyber&quot;</span>));</div>
<div class="line"><span class="comment">// proto message Chatter</span></div>
<div class="line">Chatter chatter;</div>
<div class="line">Parameter f(<span class="stringliteral">&quot;chatter&quot;</span>, chatter);</div>
<div class="line">std::string msg_str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">chatter.SerializeToString(&amp;msg_str);</div>
<div class="line">std::string msg_desc(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">ProtobufFactory::GetDescriptorString(chatter, &amp;msg_desc);</div>
<div class="line">Parameter g(<span class="stringliteral">&quot;chatter&quot;</span>, msg_str, Chatter::descriptor()-&gt;full_name(), msg_desc);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Interface and Data Reading</h3>
<p>Interface list:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> ParamType type() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> std::string TypeName() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> std::string Descriptor() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> std::string Name() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> AsBool() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> int64_t AsInt64() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> AsDouble() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> std::string AsString() <span class="keyword">const</span>;</div>
<div class="line">std::string DebugString() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_base_of&lt;google::protobuf::Message, Type&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;Type&gt;::value &amp;&amp; !std::is_same&lt;Type, bool&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;Type&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;Type, std::string&gt;::value, <span class="keyword">const</span> std::string&amp;&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;Type, bool&gt;::value, <span class="keywordtype">bool</span>&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>An example of how to use those interfaces:</p>
<div class="fragment"><div class="line">Parameter a(<span class="stringliteral">&quot;int&quot;</span>, 10);</div>
<div class="line">a.Name();  <span class="comment">// return int</span></div>
<div class="line">a.Type();  <span class="comment">// return apollo::cyber::proto::ParamType::INT</span></div>
<div class="line">a.TypeName();  <span class="comment">// return string: INT</span></div>
<div class="line">a.DebugString();  <span class="comment">// return string: {name: &quot;int&quot;, type: &quot;INT&quot;, value: 10}</span></div>
<div class="line"><span class="keywordtype">int</span> x = a.AsInt64();  <span class="comment">// x = 10</span></div>
<div class="line">x = a.value&lt;int64_t&gt;();  <span class="comment">// x = 10</span></div>
<div class="line">x = a.AsString();  <span class="comment">// Undefined behavior, error log prompt</span></div>
<div class="line">f.TypeName();  <span class="comment">// return string: chatter</span></div>
<div class="line"><span class="keyword">auto</span> chatter = f.value&lt;Chatter&gt;();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Parameter Service</h2>
<p>If a node wants to provide a Parameter Service to other nodes, then you need to create a <code>ParameterService</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">explicit</span> ParameterService(<span class="keyword">const</span> std::shared_ptr&lt;Node&gt;&amp; node);</div>
</div><!-- fragment --><p>Since all parameters are stored in the parameter service object, the parameters can be manipulated directly in the ParameterService without sending a service request.</p>
<p><b>Setting parameters:</b></p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SetParameter(<span class="keyword">const</span> Parameter&amp; parameter);</div>
</div><!-- fragment --><p><b>Getting parameters:</b></p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> GetParameter(<span class="keyword">const</span> std::string&amp; param_name, Parameter* parameter);</div>
</div><!-- fragment --><p><b>Getting the list of parameters:</b></p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ListParameters(std::vector&lt;Parameter&gt;* parameters);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
Parameter Client</h2>
<p>If a node wants to use parameter services of other nodes, you need to create a <code>ParameterClient</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">ParameterClient(<span class="keyword">const</span> std::shared_ptr&lt;Node&gt;&amp; node, <span class="keyword">const</span> std::string&amp; service_node_name);</div>
</div><!-- fragment --><p>You could also perform <code>SetParameter</code>, <code>GetParameter</code> and <code>ListParameters</code> mentioned under <a href="#Parameter-Service">Parameter Service</a>.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Demo - example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/parameter/parameter_client.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/parameter/parameter_server.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Parameter.html">apollo::cyber::Parameter</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1ParameterServer.html">apollo::cyber::ParameterServer</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1ParameterClient.html">apollo::cyber::ParameterClient</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  apollo::cyber::Init(*argv);</div>
<div class="line">  std::shared_ptr&lt;apollo::cyber::Node&gt; node =</div>
<div class="line">      apollo::cyber::CreateNode(<span class="stringliteral">&quot;parameter&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> param_server = std::make_shared&lt;ParameterServer&gt;(node);</div>
<div class="line">  <span class="keyword">auto</span> param_client = std::make_shared&lt;ParameterClient&gt;(node, <span class="stringliteral">&quot;parameter&quot;</span>);</div>
<div class="line">  param_server-&gt;SetParameter(Parameter(<span class="stringliteral">&quot;int&quot;</span>, 1));</div>
<div class="line">  Parameter parameter;</div>
<div class="line">  param_server-&gt;GetParameter(<span class="stringliteral">&quot;int&quot;</span>, &amp;parameter);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;int: &quot;</span> &lt;&lt; parameter.AsInt64();</div>
<div class="line">  param_client-&gt;SetParameter(Parameter(<span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;test&quot;</span>));</div>
<div class="line">  param_client-&gt;GetParameter(<span class="stringliteral">&quot;string&quot;</span>, &amp;parameter);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;string: &quot;</span> &lt;&lt; parameter.AsString();</div>
<div class="line">  param_client-&gt;GetParameter(<span class="stringliteral">&quot;int&quot;</span>, &amp;parameter);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;int: &quot;</span> &lt;&lt; parameter.AsInt64();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1ParameterClient_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1ParameterClient.html">apollo::cyber::ParameterClient</a></div><div class="ttdoc">Parameter Client is used to set/get/list parameter(s) by sending a request to ParameterServer.</div><div class="ttdef"><b>Definition:</b> parameter_client.h:39</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1ParameterServer_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1ParameterServer.html">apollo::cyber::ParameterServer</a></div><div class="ttdoc">Parameter Service is a very important function of auto-driving. If you want to set a key-value,...</div><div class="ttdef"><b>Definition:</b> parameter_server.h:44</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1Parameter_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1Parameter.html">apollo::cyber::Parameter</a></div><div class="ttdoc">A Parameter holds an apollo::cyber::proto::Param, It's more human-readable, you can use basic-value t...</div><div class="ttdef"><b>Definition:</b> parameter.h:42</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Build and run</h3>
<ul>
<li>Build: bazel build cyber/examples/…</li>
<li>Run: ./bazel-bin/cyber/examples/paramserver</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Log API</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Log library</h2>
<p>Cyber log library is built on top of glog. The following header files need to be included:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/common/log.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/init.h&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
Log configuration</h2>
<p>Default global config path: cyber/setup.bash</p>
<p>The configs below could be modified by devloper:</p>
<div class="fragment"><div class="line">export GLOG_log_dir=/apollo/data/log</div>
<div class="line">export GLOG_alsologtostderr=0</div>
<div class="line">export GLOG_colorlogtostderr=1</div>
<div class="line">export GLOG_minloglevel=0</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Log initialization</h2>
<p>Call the Init method at the code entry to initialize the log:</p>
<div class="fragment"><div class="line"> {cpp++}</div>
<div class="line">apollo::cyber::cyber::Init(argv[0]) is initialized.</div>
<div class="line">If no macro definition is made in the previous component, the corresponding log is printed to the binary log.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Log output macro</h2>
<p>Log library is encapsulated in Log printing macros. The related log macros are used as follows:</p>
<div class="fragment"><div class="line">ADEBUG &lt;&lt; <span class="stringliteral">&quot;hello cyber.&quot;</span>;</div>
<div class="line">AINFO  &lt;&lt; <span class="stringliteral">&quot;hello cyber.&quot;</span>;</div>
<div class="line">AWARN  &lt;&lt; <span class="stringliteral">&quot;hello cyber.&quot;</span>;</div>
<div class="line">AERROR &lt;&lt; <span class="stringliteral">&quot;hello cyber.&quot;</span>;</div>
<div class="line">AFATAL &lt;&lt; <span class="stringliteral">&quot;hello cyber.&quot;</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Log format</h2>
<p>The format is <code>&lt;MODULE_NAME&gt;.log.&lt;LOG_LEVEL&gt;.&lt;datetime&gt;.&lt;process_id&gt;</code></p>
<h2><a class="anchor" id="autotoc_md33"></a>
About log files</h2>
<p>Currently, the only different output behavior from default glog is that different log levels of a module will be written into the same log file.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Building a module based on Component</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Key concepts</h2>
<h3><a class="anchor" id="autotoc_md36"></a>
1. Component</h3>
<p>The component is the base class that Cyber RT provides to build application modules. Each specific application module can inherit the Component class and define its own <code>Init</code> and <code>Proc</code> functions so that it can be loaded into the Cyber framework.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
2. Binary vs Component</h3>
<p>There are two options to use Cyber RT framework for applications:</p>
<ul>
<li>Binary based: the application is compiled separately into a binary, which communicates with other cyber modules by creating its own <code>Reader</code> and <code>Writer</code>.</li>
<li>Component based: the application is compiled into a Shared Library. By inheriting the Component class and writing the corresponding dag description file, the Cyber RT framework will load and run the application dynamically.</li>
</ul>
<h4><a class="anchor" id="autotoc_md38"></a>
The essential Component interface</h4>
<ul>
<li>The component's <code>Init()</code> function is like the main function that does some initialization of the algorithm.</li>
<li>Component's <code>Proc()</code> function works like Reader's callback function that is called by the framework when a message arrives.</li>
</ul>
<h4><a class="anchor" id="autotoc_md39"></a>
Advantages of using Component</h4>
<ul>
<li>Component can be loaded into different processes through the launch file, and the deployment is flexible.</li>
<li>Component can change the received channel name by modifying the dag file without recompiling.</li>
<li>Component supports receiving multiple types of data.</li>
<li>Component supports providing multiple fusion strategies.</li>
</ul>
<h3><a class="anchor" id="autotoc_md40"></a>
3. Dag file format</h3>
<p>An example dag file:</p>
<div class="fragment"><div class="line"># Define all coms in DAG streaming.</div>
<div class="line">module_config {</div>
<div class="line">    module_library : &quot;lib/libperception_component.so&quot;</div>
<div class="line">    components {</div>
<div class="line">        class_name : &quot;PerceptionComponent&quot;</div>
<div class="line">        config {</div>
<div class="line">            name : &quot;perception&quot;</div>
<div class="line">            readers {</div>
<div class="line">                channel: &quot;perception/channel_name&quot;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    timer_components {</div>
<div class="line">        class_name : &quot;DriverComponent&quot;</div>
<div class="line">        config {</div>
<div class="line">            name : &quot;driver&quot;</div>
<div class="line">            interval : 100</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>module_library</b>: If you want to load the .so library the root directory is the working directory of cyber (the same directory of <code>setup.bash</code>)</li>
<li><b>components &amp; timer_component</b>: Select the base component class type that needs to be loaded.</li>
<li><b>class_name</b>: the name of the component class to load</li>
<li><b>name</b>: the loaded class_name as the identifier of the loading example</li>
<li><b>readers</b>: Data received by the current component, supporting 1-3 channels of data.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
Demo - examples</h2>
<h3><a class="anchor" id="autotoc_md42"></a>
Common_component_example(cyber/examples/common_component_example/*)</h3>
<p>Header definition(<a class="el" href="common__component__example_8h_source.html">common_component_example.h</a>)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cyber/class_loader/class_loader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/component/component.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/examples/proto/examples.pb.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1examples_1_1proto_1_1Driver.html">apollo::cyber::examples::proto::Driver</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Component.html">apollo::cyber::Component</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1ComponentBase.html">apollo::cyber::ComponentBase</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Commontestcomponent : <span class="keyword">public</span> Component&lt;Driver, Driver&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> Init() <span class="keyword">override</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> Proc(<span class="keyword">const</span> std::shared_ptr&lt;Driver&gt;&amp; msg0,</div>
<div class="line">            <span class="keyword">const</span> std::shared_ptr&lt;Driver&gt;&amp; msg1) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line">CYBER_REGISTER_COMPONENT(Commontestcomponent)</div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1ComponentBase_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1ComponentBase.html">apollo::cyber::ComponentBase</a></div><div class="ttdef"><b>Definition:</b> component_base.h:41</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1Component_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1Component.html">apollo::cyber::Component</a></div><div class="ttdoc">The Component can process up to four channels of messages. The message type is specified when the com...</div><div class="ttdef"><b>Definition:</b> component.h:58</div></div>
</div><!-- fragment --><p>Cpp file implementation(common_component_example.cc)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/examples/common_component_smaple/common_component_example.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cyber/class_loader/class_loader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/component/component.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> Commontestcomponent::Init() {</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;Commontest component init&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> Commontestcomponent::Proc(<span class="keyword">const</span> std::shared_ptr&lt;Driver&gt;&amp; msg0,</div>
<div class="line">                               <span class="keyword">const</span> std::shared_ptr&lt;Driver&gt;&amp; msg1) {</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;Start commontest component Proc [&quot;</span> &lt;&lt; msg0-&gt;msg_id() &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span></div>
<div class="line">        &lt;&lt; msg1-&gt;msg_id() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md43"></a>
Timer_component_example(cyber/examples/timer_component_example/*)</h3>
<p>Header definition(<a class="el" href="timer__component__example_8h_source.html">timer_component_example.h</a>)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cyber/class_loader/class_loader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/component/component.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/component/timer_component.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/examples/proto/examples.pb.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1examples_1_1proto_1_1Driver.html">apollo::cyber::examples::proto::Driver</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Component.html">apollo::cyber::Component</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1ComponentBase.html">apollo::cyber::ComponentBase</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1TimerComponent.html">apollo::cyber::TimerComponent</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classapollo_1_1cyber_1_1Writer.html">apollo::cyber::Writer</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TimertestComponent : <span class="keyword">public</span> TimerComponent {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> Init() <span class="keyword">override</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> Proc() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::shared_ptr&lt;Writer&lt;Driver&gt;&gt; driver_writer_ = <span class="keyword">nullptr</span>;</div>
<div class="line">};</div>
<div class="line">CYBER_REGISTER_COMPONENT(TimertestComponent)</div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1TimerComponent_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1TimerComponent.html">apollo::cyber::TimerComponent</a></div><div class="ttdoc">TimerComponent is a timer component. Your component can inherit from Component, and implement Init() ...</div><div class="ttdef"><b>Definition:</b> timer_component.h:35</div></div>
<div class="ttc" id="aclassapollo_1_1cyber_1_1Writer_html"><div class="ttname"><a href="classapollo_1_1cyber_1_1Writer.html">apollo::cyber::Writer</a></div><div class="ttdef"><b>Definition:</b> writer.h:42</div></div>
</div><!-- fragment --><p>Cpp file implementation(timer_component_example.cc)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyber/examples/timer_component_example/timer_component_example.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cyber/class_loader/class_loader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/component/component.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/examples/proto/examples.pb.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> TimertestComponent::Init() {</div>
<div class="line">  driver_writer_ = node_-&gt;CreateWriter&lt;Driver&gt;(<span class="stringliteral">&quot;/carstatus/channel&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> TimertestComponent::Proc() {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line">  <span class="keyword">auto</span> out_msg = std::make_shared&lt;Driver&gt;();</div>
<div class="line">  out_msg-&gt;set_msg_id(i++);</div>
<div class="line">  driver_writer_-&gt;Write(out_msg);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;timertestcomponent: Write drivermsg-&gt;&quot;</span></div>
<div class="line">        &lt;&lt; out_msg-&gt;ShortDebugString();</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md44"></a>
Build and run</h3>
<p>Use timertestcomponent as example:</p>
<ul>
<li>Build: bazel build cyber/examples/timer_component_smaple/…</li>
<li>Run: mainboard -d cyber/examples/timer_component_smaple/timer.dag</li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Precautions</h2>
<ul>
<li>Component needs to be registered to load the class through SharedLibrary. The registration interface looks like:</li>
</ul>
<div class="fragment"><div class="line">CYBER_REGISTER_COMPONENT(DriverComponent)</div>
</div><!-- fragment --><p>If you use a namespace when registering, you also need to add a namespace when you define it in the dag file.</p>
<ul>
<li>The configuration files of the Component and TimerComponent are different, please be careful not to mix the two up.</li>
</ul>
<h1><a class="anchor" id="autotoc_md46"></a>
Launch</h1>
<p><b>cyber_launch</b> is the launcher of the Cyber RT framework. It starts multiple mainboards according to the launch file, and loads different components into different mainboards according to the dag file. cyber_launch supports two scenarios for dynamically loading components or starting Binary programs in a child process.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Launch File Format</h2>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">cyber</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">module</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">driver</span>&lt;/<span class="keywordtype">name</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">dag_conf</span>&gt;<span class="keyword">driver.dag</span>&lt;/<span class="keywordtype">dag_conf</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">process_name</span>&gt;&lt;/<span class="keywordtype">process_name</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">exception_handler</span>&gt;<span class="keyword">exit</span>&lt;/<span class="keywordtype">exception_handler</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">module</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">module</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">perception</span>&lt;/<span class="keywordtype">name</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">dag_conf</span>&gt;<span class="keyword">perception.dag</span>&lt;/<span class="keywordtype">dag_conf</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">process_name</span>&gt;&lt;/<span class="keywordtype">process_name</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">exception_handler</span>&gt;<span class="keyword">respawn</span>&lt;/<span class="keywordtype">exception_handler</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">module</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">module</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">planning</span>&lt;/<span class="keywordtype">name</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">dag_conf</span>&gt;<span class="keyword">planning.dag</span>&lt;/<span class="keywordtype">dag_conf</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">process_name</span>&gt;&lt;/<span class="keywordtype">process_name</span>&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">module</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">cyber</span>&gt;</div>
</div><!-- fragment --><p><b>Module</b>: Each loaded component or binary is a module</p>
<ul>
<li><b>name</b> is the loaded module name</li>
<li><b>dag_conf</b> is the name of the corresponding dag file of the component</li>
<li><b>process_name</b> is the name of the mainboard process once started, and the same component of process_name will be loaded and run in the same process.</li>
<li><b>exception_handler</b> is the handler method when the exception occurs in the process. The value can be exit or respawn listed below.<ul>
<li>exit, which means that the entire process needs to stop running when the current process exits abnormally.</li>
<li>respawn, the current process needs to be restarted after abnormal exit. Start this process. If there is no such thing as it is empty, it means no treatment. Can be controlled by the user according to the specific conditions of the process</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md48"></a>
Timer</h1>
<p>Timer can be used to create a timed task to run on a periodic basis, or to run only once</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Timer Interface</h2>
<div class="fragment"><div class="line"> </div>
<div class="line">Timer(uint32_t period, std::function&lt;<span class="keywordtype">void</span>()&gt; callback, <span class="keywordtype">bool</span> oneshot);</div>
</div><!-- fragment --><p>Or you could encapsulate the parameters into a timer option as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TimerOption {</div>
<div class="line">  uint32_t period;                 <span class="comment">// The period of the timer, unit is ms</span></div>
<div class="line">  std::function&lt;void()&gt; callback;  <span class="comment">// The tasks that the timer needs to perform</span></div>
<div class="line">  <span class="keywordtype">bool</span> oneshot;  <span class="comment">// True: perform the callback only after the first timing cycle</span></div>
<div class="line">                 <span class="comment">// False: perform the callback every timed period</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">explicit</span> Timer(TimerOption opt);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md50"></a>
Start Timer</h2>
<p>After creating a Timer instance, you must call <code>Timer::Start()</code> to start the timer.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Stop Timer</h2>
<p>When you need to manually stop a timer that has already started, you can call the <code>Timer::Stop()</code> interface.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Demo - example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    cyber::Init(argv[0]);</div>
<div class="line">    <span class="comment">// Print current time every 100ms</span></div>
<div class="line">    cyber::Timer timer(100, [](){</div>
<div class="line">        std::cout &lt;&lt; cyber::Time::Now() &lt;&lt; std::endl;</div>
<div class="line">    }, <span class="keyword">false</span>);</div>
<div class="line">    timer.Start()</div>
<div class="line">    sleep(1);</div>
<div class="line">    timer.Stop();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md53"></a>
Time API</h1>
<p>Time is a class used to manage time; it can be used for current time acquisition, time-consuming calculation, time conversion, and so on.</p>
<p>The time interfaces are as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// constructor, passing in a different value to construct Time</span></div>
<div class="line">Time(uint64_t nanoseconds); <span class="comment">//uint64_t, in nanoseconds</span></div>
<div class="line">Time(<span class="keywordtype">int</span> nanoseconds); <span class="comment">// int type, unit: nanoseconds</span></div>
<div class="line">Time(<span class="keywordtype">double</span> seconds); <span class="comment">// double, in seconds</span></div>
<div class="line">Time(uint32_t seconds, uint32_t nanoseconds);</div>
<div class="line"><span class="comment">// seconds seconds + nanoseconds nanoseconds</span></div>
<div class="line">Static Time Now(); <span class="comment">// Get the current time</span></div>
<div class="line">Double ToSecond() <span class="keyword">const</span>; <span class="comment">// convert to seconds</span></div>
<div class="line">Uint64_t ToNanosecond() <span class="keyword">const</span>; <span class="comment">// Convert to nanoseconds</span></div>
<div class="line">Std::string ToString() <span class="keyword">const</span>; <span class="comment">// Convert to a string in the format &quot;2018-07-10 20:21:51.123456789&quot;</span></div>
<div class="line">Bool IsZero() <span class="keyword">const</span>; <span class="comment">// Determine if the time is 0</span></div>
</div><!-- fragment --><p>A code example can be seen below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/duration.h&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    cyber::Init(argv[0]);</div>
<div class="line">    Time t1(1531225311123456789UL);</div>
<div class="line">    std::cout &lt;&lt; t1.ToString() &lt;&lt; std::endl; <span class="comment">// 2018-07-10 20:21:51.123456789</span></div>
<div class="line">    <span class="comment">// Duration time interval</span></div>
<div class="line">    Time t1(100);</div>
<div class="line">    Duration d(200);</div>
<div class="line">    Time t2(300);</div>
<div class="line">    assert(d == (t1-t2)); <span class="comment">// true</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md54"></a>
Record file: Read and Write</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
Reading the Reader file</h2>
<p><b>RecordReader</b> is the component used to read messages in the cyber framework. Each RecordReader can open an existing record file through the <code>Open</code> method, and the thread will asynchronously read the information in the record file. The user only needs to execute ReadMessage to extract the latest message in RecordReader, and then get the message information through GetCurrentMessageChannelName, GetCurrentRawMessage, GetCurrentMessageTime.</p>
<p><b>RecordWriter</b> is the component used to record messages in the cyber framework. Each RecordWriter can create a new record file through the Open method. The user only needs to execute WriteMessage and WriteChannel to write message and channel information, and the writing process is asynchronous.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Demo - example(cyber/examples/record.cc)</h2>
<p>Write 100 RawMessage to<code>TEST_FILE</code> through <code>test_write</code> method, then read them out through <code>test_read</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cyber/cyber.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/message/raw_message.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/proto/record.pb.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/record/record_message.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/record/record_reader.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cyber/record/record_writer.h&quot;</span></div>
<div class="line"> </div>
<div class="line">using ::apollo::cyber::record::RecordReader;</div>
<div class="line">using ::apollo::cyber::record::RecordWriter;</div>
<div class="line">using ::apollo::cyber::record::RecordMessage;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="structapollo_1_1cyber_1_1message_1_1RawMessage.html">apollo::cyber::message::RawMessage</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> CHANNEL_NAME_1[] = <span class="stringliteral">&quot;/test/channel1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> CHANNEL_NAME_2[] = <span class="stringliteral">&quot;/test/channel2&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> MESSAGE_TYPE_1[] = <span class="stringliteral">&quot;apollo.cyber.proto.Test&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> MESSAGE_TYPE_2[] = <span class="stringliteral">&quot;apollo.cyber.proto.Channel&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> PROTO_DESC[] = <span class="stringliteral">&quot;1234567890&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> STR_10B[] = <span class="stringliteral">&quot;1234567890&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> TEST_FILE[] = <span class="stringliteral">&quot;test.record&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_write(<span class="keyword">const</span> std::string &amp;writefile) {</div>
<div class="line">  RecordWriter writer;</div>
<div class="line">  writer.SetSizeOfFileSegmentation(0);</div>
<div class="line">  writer.SetIntervalOfFileSegmentation(0);</div>
<div class="line">  writer.Open(writefile);</div>
<div class="line">  writer.WriteChannel(CHANNEL_NAME_1, MESSAGE_TYPE_1, PROTO_DESC);</div>
<div class="line">  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; 100; ++i) {</div>
<div class="line">    <span class="keyword">auto</span> msg = std::make_shared&lt;RawMessage&gt;(<span class="stringliteral">&quot;abc&quot;</span> + std::to_string(i));</div>
<div class="line">    writer.WriteMessage(CHANNEL_NAME_1, msg, 888 + i);</div>
<div class="line">  }</div>
<div class="line">  writer.Close();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test_read(<span class="keyword">const</span> std::string &amp;readfile) {</div>
<div class="line">  RecordReader reader(readfile);</div>
<div class="line">  RecordMessage message;</div>
<div class="line">  uint64_t msg_count = reader.GetMessageNumber(CHANNEL_NAME_1);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;MSGTYPE: &quot;</span> &lt;&lt; reader.GetMessageType(CHANNEL_NAME_1);</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;MSGDESC: &quot;</span> &lt;&lt; reader.GetProtoDesc(CHANNEL_NAME_1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// read all message</span></div>
<div class="line">  uint64_t i = 0;</div>
<div class="line">  uint64_t valid = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; msg_count; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (reader.ReadMessage(&amp;message)) {</div>
<div class="line">      AINFO &lt;&lt; <span class="stringliteral">&quot;msg[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;]-&gt; &quot;</span></div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;channel name: &quot;</span> &lt;&lt; message.channel_name</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;; content: &quot;</span> &lt;&lt; message.content</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;; msg time: &quot;</span> &lt;&lt; message.time;</div>
<div class="line">      valid++;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      AERROR &lt;&lt; <span class="stringliteral">&quot;read msg[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] failed&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;static msg=================&quot;</span>;</div>
<div class="line">  AINFO &lt;&lt; <span class="stringliteral">&quot;MSG validmsg:totalcount: &quot;</span> &lt;&lt; valid &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; msg_count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  apollo::cyber::Init(argv[0]);</div>
<div class="line">  test_write(TEST_FILE);</div>
<div class="line">  sleep(1);</div>
<div class="line">  test_read(TEST_FILE);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructapollo_1_1cyber_1_1message_1_1RawMessage_html"><div class="ttname"><a href="structapollo_1_1cyber_1_1message_1_1RawMessage.html">apollo::cyber::message::RawMessage</a></div><div class="ttdef"><b>Definition:</b> raw_message.h:31</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md57"></a>
Build and run</h3>
<ul>
<li>Build: bazel build cyber/examples/…</li>
<li>Run: ./bazel-bin/cyber/examples/record</li>
<li>Examining result:</li>
</ul>
<div class="fragment"><div class="line">I1124 16:56:27.248200 15118 record.cc:64] [record] msg[0]-&gt; channel name: /test/channel1; content: abc0; msg time: 888</div>
<div class="line">I1124 16:56:27.248227 15118 record.cc:64] [record] msg[1]-&gt; channel name: /test/channel1; content: abc1; msg time: 889</div>
<div class="line">I1124 16:56:27.248239 15118 record.cc:64] [record] msg[2]-&gt; channel name: /test/channel1; content: abc2; msg time: 890</div>
<div class="line">I1124 16:56:27.248252 15118 record.cc:64] [record] msg[3]-&gt; channel name: /test/channel1; content: abc3; msg time: 891</div>
<div class="line">I1124 16:56:27.248297 15118 record.cc:64] [record] msg[4]-&gt; channel name: /test/channel1; content: abc4; msg time: 892</div>
<div class="line">I1124 16:56:27.248378 15118 record.cc:64] [record] msg[5]-&gt; channel name: /test/channel1; content: abc5; msg time: 893</div>
<div class="line">...</div>
<div class="line">I1124 16:56:27.250422 15118 record.cc:73] [record] static msg=================</div>
<div class="line">I1124 16:56:27.250434 15118 record.cc:74] [record] MSG validmsg:totalcount: 100:100</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md58"></a>
API Directory</h1>
<h2><a class="anchor" id="autotoc_md59"></a>
Node API</h2>
<p>For additional information and examples, refer to <a href="#node">Node</a></p>
<h2><a class="anchor" id="autotoc_md60"></a>
API List</h2>
<div class="fragment"><div class="line"><span class="comment">//create writer with user-define attr and message type</span></div>
<div class="line"><span class="keyword">auto</span> CreateWriter(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr)</div>
<div class="line">    -&gt; std::shared_ptr&lt;transport::Writer&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="comment">//create reader with user-define attr, callback and message type</span></div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr,</div>
<div class="line">    <span class="keyword">const</span> croutine::CRoutineFunc&lt;MessageT&gt;&amp; reader_func)</div>
<div class="line">    -&gt; std::shared_ptr&lt;transport::Reader&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="comment">//create writer with specific channel name and message type</span></div>
<div class="line"><span class="keyword">auto</span> CreateWriter(<span class="keyword">const</span> std::string&amp; channel_name)</div>
<div class="line">    -&gt; std::shared_ptr&lt;transport::Writer&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="comment">//create reader with specific channel name, callback and message type</span></div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> std::string&amp; channel_name,</div>
<div class="line">    <span class="keyword">const</span> croutine::CRoutineFunc&lt;MessageT&gt;&amp; reader_func)</div>
<div class="line">    -&gt; std::shared_ptr&lt;transport::Reader&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="comment">//create reader with user-define config, callback and message type</span></div>
<div class="line"><span class="keyword">auto</span> CreateReader(<span class="keyword">const</span> ReaderConfig&amp; config,</div>
<div class="line">                  <span class="keyword">const</span> CallbackFunc&lt;MessageT&gt;&amp; reader_func)</div>
<div class="line">    -&gt; std::shared_ptr&lt;cybertron::Reader&lt;MessageT&gt;&gt;;</div>
<div class="line"><span class="comment">//create service with name and specific callback</span></div>
<div class="line"><span class="keyword">auto</span> CreateService(<span class="keyword">const</span> std::string&amp; service_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> service::Service&lt;Request, Response&gt;::ServiceCallback&amp; service_calllback)</div>
<div class="line">    -&gt; std::shared_ptr&lt;service::Service&lt;Request, Response&gt;&gt;;</div>
<div class="line"><span class="comment">//create client with name to send request to server</span></div>
<div class="line"><span class="keyword">auto</span> CreateClient(<span class="keyword">const</span> std::string&amp; service_name)</div>
<div class="line">    -&gt; std::shared_ptr&lt;service::Client&lt;Request, Response&gt;&gt;;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md61"></a>
Writer API</h1>
<p>For additional information and examples, refer to <a href="#writer">Writer</a></p>
<h2><a class="anchor" id="autotoc_md62"></a>
API List</h2>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> Write(<span class="keyword">const</span> std::shared_ptr&lt;MessageT&gt;&amp; message);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md63"></a>
Client API</h1>
<p>For additional information and examples, refer to <a href="#service-creation-and-use">Client</a></p>
<h2><a class="anchor" id="autotoc_md64"></a>
API List</h2>
<div class="fragment"><div class="line">SharedResponse SendRequest(SharedRequest request,</div>
<div class="line">                           <span class="keyword">const</span> std::chrono::seconds&amp; timeout_s = std::chrono::seconds(5));</div>
<div class="line">SharedResponse SendRequest(<span class="keyword">const</span> Request&amp; request,</div>
<div class="line">                           <span class="keyword">const</span> std::chrono::seconds&amp; timeout_s = std::chrono::seconds(5));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md65"></a>
Parameter API</h1>
<p>The interface that the user uses to perform parameter related operations:</p>
<ul>
<li>Set the parameter related API.</li>
<li>Read the parameter related API.</li>
<li>Create a ParameterService to provide parameter service related APIs for other nodes.</li>
<li>Create a ParameterClient that uses the parameters provided by other nodes to service related APIs.</li>
</ul>
<p>For additional information and examples, refer to <a href="##param-parameter-service">Parameter</a></p>
<h2><a class="anchor" id="autotoc_md66"></a>
API List - Setting parameters</h2>
<div class="fragment"><div class="line">Parameter();  <span class="comment">// Name is empty, type is NOT_SET</span></div>
<div class="line"><span class="keyword">explicit</span> Parameter(<span class="keyword">const</span> Parameter&amp; parameter);</div>
<div class="line"><span class="keyword">explicit</span> Parameter(<span class="keyword">const</span> std::string&amp; name);  <span class="comment">// Type is NOT_SET</span></div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">bool</span> bool_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">int</span> int_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> int64_t int_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">float</span> double_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">double</span> double_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; string_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">char</span>* string_value);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; msg_str,</div>
<div class="line">          <span class="keyword">const</span> std::string&amp; full_name, <span class="keyword">const</span> std::string&amp; proto_desc);</div>
<div class="line">Parameter(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> google::protobuf::Message&amp; msg);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
API List - Reading parameters</h2>
<div class="fragment"><div class="line"><span class="keyword">inline</span> ParamType type() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> std::string TypeName() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> std::string Descriptor() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> std::string Name() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> AsBool() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> int64_t AsInt64() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> AsDouble() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> std::string AsString() <span class="keyword">const</span>;</div>
<div class="line">std::string DebugString() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_base_of&lt;google::protobuf::Message, Type&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;Type&gt;::value &amp;&amp; !std::is_same&lt;Type, bool&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;Type&gt;::value, Type&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;Type, std::string&gt;::value, <span class="keyword">const</span> std::string&amp;&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;Type, bool&gt;::value, <span class="keywordtype">bool</span>&gt;::type</div>
<div class="line">value() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
API List - Creating parameter service</h2>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> ParameterService(<span class="keyword">const</span> std::shared_ptr&lt;Node&gt;&amp; node);</div>
<div class="line"><span class="keywordtype">void</span> SetParameter(<span class="keyword">const</span> Parameter&amp; parameter);</div>
<div class="line"><span class="keywordtype">bool</span> GetParameter(<span class="keyword">const</span> std::string&amp; param_name, Parameter* parameter);</div>
<div class="line"><span class="keywordtype">bool</span> ListParameters(std::vector&lt;Parameter&gt;* parameters);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md69"></a>
API List - Creating parameter client</h2>
<div class="fragment"><div class="line">ParameterClient(<span class="keyword">const</span> std::shared_ptr&lt;Node&gt;&amp; node, <span class="keyword">const</span> std::string&amp; service_node_name);</div>
<div class="line"><span class="keywordtype">bool</span> SetParameter(<span class="keyword">const</span> Parameter&amp; parameter);</div>
<div class="line"><span class="keywordtype">bool</span> GetParameter(<span class="keyword">const</span> std::string&amp; param_name, Parameter* parameter);</div>
<div class="line"><span class="keywordtype">bool</span> ListParameters(std::vector&lt;Parameter&gt;* parameters);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md70"></a>
Timer API</h1>
<p>You can set the parameters of the Timer and call the start and stop interfaces to start the timer and stop the timer. For additional information and examples, refer to <a href="#timer">Timer</a></p>
<h2><a class="anchor" id="autotoc_md71"></a>
API List</h2>
<div class="fragment"><div class="line">Timer(uint32_t period, std::function&lt;<span class="keywordtype">void</span>()&gt; callback, <span class="keywordtype">bool</span> oneshot);</div>
<div class="line">Timer(TimerOption opt);</div>
<div class="line"><span class="keywordtype">void</span> SetTimerOption(TimerOption opt);</div>
<div class="line"><span class="keywordtype">void</span> Start();</div>
<div class="line"><span class="keywordtype">void</span> Stop();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md72"></a>
Time API</h1>
<p>For additional information and examples, refer to <a href="#use-of-time">Time</a></p>
<h2><a class="anchor" id="autotoc_md73"></a>
API List</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> Time MAX;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> Time MIN;</div>
<div class="line">Time() {}</div>
<div class="line"><span class="keyword">explicit</span> Time(uint64_t nanoseconds);</div>
<div class="line"><span class="keyword">explicit</span> Time(<span class="keywordtype">int</span> nanoseconds);</div>
<div class="line"><span class="keyword">explicit</span> Time(<span class="keywordtype">double</span> seconds);</div>
<div class="line">Time(uint32_t seconds, uint32_t nanoseconds);</div>
<div class="line">Time(<span class="keyword">const</span> Time&amp; other);</div>
<div class="line"><span class="keyword">static</span> Time Now();</div>
<div class="line"><span class="keyword">static</span> Time MonoTime();</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SleepUntil(<span class="keyword">const</span> Time&amp; time);</div>
<div class="line"><span class="keywordtype">double</span> ToSecond() <span class="keyword">const</span>;</div>
<div class="line">uint64_t ToNanosecond() <span class="keyword">const</span>;</div>
<div class="line">std::string ToString() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> IsZero() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md74"></a>
Duration API</h1>
<p>Interval-related interface, used to indicate the time interval, can be initialized according to the specified nanosecond or second.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
API List</h2>
<div class="fragment"><div class="line">Duration() {}</div>
<div class="line">Duration(int64_t nanoseconds);</div>
<div class="line">Duration(<span class="keywordtype">int</span> nanoseconds);</div>
<div class="line">Duration(<span class="keywordtype">double</span> seconds);</div>
<div class="line">Duration(uint32_t seconds, uint32_t nanoseconds);</div>
<div class="line">Duration(<span class="keyword">const</span> Rate&amp; rate);</div>
<div class="line">Duration(<span class="keyword">const</span> Duration&amp; other);</div>
<div class="line"><span class="keywordtype">double</span> ToSecond() <span class="keyword">const</span>;</div>
<div class="line">int64_t ToNanosecond() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> IsZero() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> Sleep() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md76"></a>
Rate API</h1>
<p>The frequency interface is generally used to initialize the time of the sleep frequency after the object is initialized according to the specified frequency.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
API List</h2>
<div class="fragment"><div class="line">Rate(<span class="keywordtype">double</span> frequency);</div>
<div class="line">Rate(uint64_t nanoseconds);</div>
<div class="line">Rate(<span class="keyword">const</span> Duration&amp;);</div>
<div class="line"><span class="keywordtype">void</span> Sleep();</div>
<div class="line"><span class="keywordtype">void</span> Reset();</div>
<div class="line">Duration CycleTime() <span class="keyword">const</span>;</div>
<div class="line">Duration ExpectedCycleTime()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> expected_cycle_time_; }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md78"></a>
RecordReader API</h1>
<p>The interface for reading the record file is used to read the message and channel information in the record file.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
API List</h2>
<div class="fragment"><div class="line">RecordReader();</div>
<div class="line"><span class="keywordtype">bool</span> Open(<span class="keyword">const</span> std::string&amp; filename, uint64_t begin_time = 0,</div>
<div class="line">          uint64_t end_time = UINT64_MAX);</div>
<div class="line"><span class="keywordtype">void</span> Close();</div>
<div class="line"><span class="keywordtype">bool</span> ReadMessage();</div>
<div class="line"><span class="keywordtype">bool</span> EndOfFile();</div>
<div class="line"><span class="keyword">const</span> std::string&amp; CurrentMessageChannelName();</div>
<div class="line">std::shared_ptr&lt;RawMessage&gt; CurrentRawMessage();</div>
<div class="line">uint64_t CurrentMessageTime();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md80"></a>
RecordWriter API</h1>
<p>The interface for writing the record file, used to record the message and channel information into the record file.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
API List</h2>
<div class="fragment"><div class="line">RecordWriter();</div>
<div class="line"><span class="keywordtype">bool</span> Open(<span class="keyword">const</span> std::string&amp; file);</div>
<div class="line"><span class="keywordtype">void</span> Close();</div>
<div class="line"><span class="keywordtype">bool</span> WriteChannel(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; type,</div>
<div class="line">                  <span class="keyword">const</span> std::string&amp; proto_desc);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> WriteMessage(<span class="keyword">const</span> std::string&amp; channel_name, <span class="keyword">const</span> MessageT&amp; message,</div>
<div class="line">                  <span class="keyword">const</span> uint64_t time_nanosec,</div>
<div class="line">                  <span class="keyword">const</span> std::string&amp; proto_desc = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordtype">bool</span> SetSizeOfFileSegmentation(uint64_t size_kilobytes);</div>
<div class="line"><span class="keywordtype">bool</span> SetIntervalOfFileSegmentation(uint64_t time_sec);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
