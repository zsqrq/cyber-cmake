.TH "eprosima::fastrtps::rtps::ReaderProxy" 3 "Sun Sep 3 2023" "Version 8.0" "Cyber-Cmake" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eprosima::fastrtps::rtps::ReaderProxy
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ReaderProxy\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBReaderProxy\fP (\fBRemoteReaderAttributes\fP &rdata, const \fBWriterTimes\fP &times, \fBStatefulWriter\fP *SW)"
.br
.ti -1c
.RI "void \fBdestroy_timers\fP ()"
.br
.ti -1c
.RI "void \fBaddChange\fP (const \fBChangeForReader_t\fP &)"
.br
.ti -1c
.RI "size_t \fBcountChangesForReader\fP () const"
.br
.ti -1c
.RI "bool \fBchange_is_acked\fP (const \fBSequenceNumber_t\fP &sequence_number)"
.br
.ti -1c
.RI "bool \fBacked_changes_set\fP (const \fBSequenceNumber_t\fP &seqNum)"
.br
.ti -1c
.RI "bool \fBrequested_changes_set\fP (std::vector< \fBSequenceNumber_t\fP > &seqNumSet)"
.br
.ti -1c
.RI "std::vector< \fBChangeForReader_t\fP * > \fBget_unsent_changes\fP ()"
.br
.RI "Lists all unsent changes\&. These changes are also relevants and valid\&. "
.ti -1c
.RI "std::vector< const \fBChangeForReader_t\fP * > \fBget_requested_changes\fP () const"
.br
.RI "Lists all requested changes\&. "
.ti -1c
.RI "void \fBset_change_to_status\fP (const \fBSequenceNumber_t\fP &seq_num, \fBChangeForReaderStatus_t\fP status)"
.br
.RI "Sets a change to a particular status (if present in the \fBReaderProxy\fP) "
.ti -1c
.RI "bool \fBmark_fragment_as_sent_for_change\fP (const \fBCacheChange_t\fP *change, FragmentNumber_t fragment)"
.br
.ti -1c
.RI "void \fBconvert_status_on_all_changes\fP (\fBChangeForReaderStatus_t\fP previous, \fBChangeForReaderStatus_t\fP next)"
.br
.ti -1c
.RI "void \fBsetNotValid\fP (\fBCacheChange_t\fP *change)"
.br
.ti -1c
.RI "bool \fBthereIsUnacknowledged\fP () const"
.br
.RI "Returns there is some UNACKNOWLEDGED change\&. "
.ti -1c
.RI "bool \fBunacked_changes\fP (std::vector< const \fBChangeForReader_t\fP * > *reqChanges)"
.br
.ti -1c
.RI "bool \fBminChange\fP (std::vector< \fBChangeForReader_t\fP * > *Changes, \fBChangeForReader_t\fP *changeForReader)"
.br
.ti -1c
.RI "bool \fBrequested_fragment_set\fP (\fBSequenceNumber_t\fP sequence_number, const \fBFragmentNumberSet_t\fP &frag_set)"
.br
.RI "Adds requested fragments\&. These fragments will be sent in next \fBNackResponseDelay\fP\&. "
.ti -1c
.RI "uint32_t \fBgetLastNackfragCount\fP () const"
.br
.RI "Returns the last NACKFRAG count\&. "
.ti -1c
.RI "void \fBsetLastNackfragCount\fP (uint32_t lastNackfragCount)"
.br
.RI "Sets the last NACKFRAG count\&. "
.ti -1c
.RI "bool \fBrtps_is_relevant\fP (\fBCacheChange_t\fP *change)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBRemoteReaderAttributes\fP \fBm_att\fP"
.br
.RI "Attributes of the Remote Reader\&. "
.ti -1c
.RI "\fBStatefulWriter\fP * \fBmp_SFW\fP"
.br
.RI "Pointer to the associated \fBStatefulWriter\fP\&. "
.ti -1c
.RI "\fBNackResponseDelay\fP * \fBmp_nackResponse\fP"
.br
.RI "Timed Event to manage the Acknack response delay\&. "
.ti -1c
.RI "\fBNackSupressionDuration\fP * \fBmp_nackSupression\fP"
.br
.RI "Timed Event to manage the delay to mark a change as UNACKED after sending it\&. "
.ti -1c
.RI "\fBInitialHeartbeat\fP * \fBmp_initialHeartbeat\fP"
.br
.RI "Timed Event to send initial heartbeat\&. "
.ti -1c
.RI "uint32_t \fBm_lastAcknackCount\fP"
.br
.RI "Last ack/nack count\&. "
.ti -1c
.RI "std::recursive_mutex * \fBmp_mutex\fP"
.br
.RI "Mutex\&. "
.ti -1c
.RI "std::set< \fBChangeForReader_t\fP, \fBChangeForReaderCmp\fP > \fBm_changesForReader\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBReaderProxy\fP class that helps to keep the state of a specific Reader with respect to the \fBRTPSWriter\fP\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "eprosima::fastrtps::rtps::ReaderProxy::ReaderProxy (\fBRemoteReaderAttributes\fP & rdata, const \fBWriterTimes\fP & times, \fBStatefulWriter\fP * SW)"
Constructor\&. 
.PP
\fBParameters\fP
.RS 4
\fIrdata\fP \fBRemoteWriterAttributes\fP to use in the creation\&. 
.br
\fItimes\fP \fBWriterTimes\fP to use in the \fBReaderProxy\fP\&. 
.br
\fISW\fP Pointer to the \fBStatefulWriter\fP\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool eprosima::fastrtps::rtps::ReaderProxy::acked_changes_set (const \fBSequenceNumber_t\fP & seqNum)"
Mark all changes up to the one indicated by the seqNum as Acknowledged\&. If seqNum == 30, changes 1-29 are marked as ack\&. 
.PP
\fBParameters\fP
.RS 4
\fIseqNum\fP Pointer to the seqNum 
.RE
.PP
\fBReturns\fP
.RS 4
True if all changes are acknowledge and anyone with other state\&. 
.RE
.PP

.SS "std::vector<const \fBChangeForReader_t\fP*> eprosima::fastrtps::rtps::ReaderProxy::get_requested_changes () const"

.PP
Lists all requested changes\&. 
.PP
\fBReturns\fP
.RS 4
STL vector with the requested change list\&. 
.RE
.PP

.SS "std::vector<\fBChangeForReader_t\fP*> eprosima::fastrtps::rtps::ReaderProxy::get_unsent_changes ()"

.PP
Lists all unsent changes\&. These changes are also relevants and valid\&. 
.PP
\fBReturns\fP
.RS 4
STL vector with the unsent change list\&. 
.RE
.PP

.SS "uint32_t eprosima::fastrtps::rtps::ReaderProxy::getLastNackfragCount () const\fC [inline]\fP"

.PP
Returns the last NACKFRAG count\&. 
.PP
\fBReturns\fP
.RS 4
Last NACKFRAG count\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::minChange (std::vector< \fBChangeForReader_t\fP * > * Changes, \fBChangeForReader_t\fP * changeForReader)"
Return the minimum change in a vector of \fBCacheChange_t\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIChanges\fP Pointer to a vector of \fBCacheChange_t\fP\&. 
.br
\fIchangeForReader\fP Pointer to the \fBCacheChange_t\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::requested_changes_set (std::vector< \fBSequenceNumber_t\fP > & seqNumSet)"
Mark all changes in the vector as requested\&. 
.PP
\fBParameters\fP
.RS 4
\fIseqNumSet\fP Vector of sequenceNumbers 
.RE
.PP
\fBReturns\fP
.RS 4
False if any change was set REQUESTED\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::requested_fragment_set (\fBSequenceNumber_t\fP sequence_number, const \fBFragmentNumberSet_t\fP & frag_set)"

.PP
Adds requested fragments\&. These fragments will be sent in next \fBNackResponseDelay\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIfrag_set\fP set containing the requested fragments to be sent\&. 
.br
\fIsequence_number\fP Sequence number to be paired with the requested fragments\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if there is at least one requested fragment\&. False in other case\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::rtps_is_relevant (\fBCacheChange_t\fP * change)\fC [inline]\fP"
Filter a \fBCacheChange_t\fP, in this version always returns true\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.SS "void eprosima::fastrtps::rtps::ReaderProxy::set_change_to_status (const \fBSequenceNumber_t\fP & seq_num, \fBChangeForReaderStatus_t\fP status)"

.PP
Sets a change to a particular status (if present in the \fBReaderProxy\fP) 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP change to search and set\&. 
.br
\fIstatus\fP Status to apply\&. 
.RE
.PP

.SS "void eprosima::fastrtps::rtps::ReaderProxy::setLastNackfragCount (uint32_t lastNackfragCount)\fC [inline]\fP"

.PP
Sets the last NACKFRAG count\&. 
.PP
\fBParameters\fP
.RS 4
\fIlastNackfragCount\fP New value for last NACKFRAG count\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::thereIsUnacknowledged () const"

.PP
Returns there is some UNACKNOWLEDGED change\&. 
.PP
\fBReturns\fP
.RS 4
There is some UNACKNOWLEDGED change\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::ReaderProxy::unacked_changes (std::vector< const \fBChangeForReader_t\fP * > * reqChanges)"
Get a vector of all unacked changes by this Reader\&. 
.PP
\fBParameters\fP
.RS 4
\fIreqChanges\fP Pointer to a vector of pointers\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Cyber-Cmake from the source code\&.
