.TH "eprosima::fastrtps::rtps::RTPSReader" 3 "Sun Sep 3 2023" "Version 8.0" "Cyber-Cmake" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eprosima::fastrtps::rtps::RTPSReader
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <RTPSReader\&.h>\fP
.PP
Inherits \fBeprosima::fastrtps::rtps::Endpoint\fP\&.
.PP
Inherited by \fBeprosima::fastrtps::rtps::StatefulReader\fP, and \fBeprosima::fastrtps::rtps::StatelessReader\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBmatched_writer_add\fP (\fBRemoteWriterAttributes\fP &wdata)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBmatched_writer_remove\fP (\fBRemoteWriterAttributes\fP &wdata)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBmatched_writer_is_matched\fP (\fBRemoteWriterAttributes\fP &wdata)=0"
.br
.ti -1c
.RI "RTPS_DllAPI bool \fBacceptMsgDirectedTo\fP (\fBEntityId_t\fP &entityId)"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBprocessDataMsg\fP (\fBCacheChange_t\fP *change)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBprocessDataFragMsg\fP (\fBCacheChange_t\fP *change, uint32_t sampleSize, uint32_t fragmentStartingNum)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBprocessHeartbeatMsg\fP (\fBGUID_t\fP &writerGUID, uint32_t hbCount, \fBSequenceNumber_t\fP &firstSN, \fBSequenceNumber_t\fP &lastSN, bool finalFlag, bool livelinessFlag)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBprocessGapMsg\fP (\fBGUID_t\fP &writerGUID, \fBSequenceNumber_t\fP &gapStart, \fBSequenceNumberSet_t\fP &gapList)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBchange_removed_by_history\fP (\fBCacheChange_t\fP *change, \fBWriterProxy\fP *prox=nullptr)=0"
.br
.ti -1c
.RI "RTPS_DllAPI \fBReaderListener\fP * \fBgetListener\fP ()"
.br
.ti -1c
.RI "RTPS_DllAPI bool \fBsetListener\fP (\fBReaderListener\fP *target)"
.br
.ti -1c
.RI "RTPS_DllAPI bool \fBreserveCache\fP (\fBCacheChange_t\fP **change, uint32_t dataCdrSerializedSize)"
.br
.ti -1c
.RI "RTPS_DllAPI void \fBreleaseCache\fP (\fBCacheChange_t\fP *change)"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBnextUnreadCache\fP (\fBCacheChange_t\fP **change, \fBWriterProxy\fP **wp)=0"
.br
.ti -1c
.RI "virtual RTPS_DllAPI bool \fBnextUntakenCache\fP (\fBCacheChange_t\fP **change, \fBWriterProxy\fP **wp)=0"
.br
.ti -1c
.RI "RTPS_DllAPI bool \fBexpectsInlineQos\fP ()"
.br
.ti -1c
.RI "RTPS_DllAPI \fBReaderHistory\fP * \fBgetHistory\fP ()"
.br
.RI "Returns a pointer to the associated \fBHistory\fP\&. "
.ti -1c
.RI "\fBCacheChange_t\fP * \fBfindCacheInFragmentedCachePitStop\fP (const \fBSequenceNumber_t\fP &sequence_number, const \fBGUID_t\fP &writer_guid)"
.br
.RI "Search if there is a \fBCacheChange_t\fP, giving \fBSequenceNumber_t\fP and writer \fBGUID_t\fP, waiting to be completed because it is fragmented\&. "
.ti -1c
.RI "virtual bool \fBisInCleanState\fP () const =0"
.br
.RI "Returns there is a clean state with all Writers\&. It occurs when the Reader received all samples sent by Writers\&. In other words, its WriterProxies are up to date\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBRTPSReader\fP (RTPSParticipantImpl *, \fBGUID_t\fP &guid, \fBReaderAttributes\fP &att, \fBReaderHistory\fP *hist, \fBReaderListener\fP *listen=nullptr)"
.br
.ti -1c
.RI "void \fBsetTrustedWriter\fP (\fBEntityId_t\fP writer)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBReaderHistory\fP * \fBmp_history\fP"
.br
.RI "\fBReaderHistory\fP\&. "
.ti -1c
.RI "\fBReaderListener\fP * \fBmp_listener\fP"
.br
.RI "Listener\&. "
.ti -1c
.RI "bool \fBm_acceptMessagesToUnknownReaders\fP"
.br
.RI "Accept msg to unknwon readers (default=true) "
.ti -1c
.RI "bool \fBm_acceptMessagesFromUnkownWriters\fP"
.br
.RI "Accept msg from unknwon writers (BE-true,RE-false) "
.ti -1c
.RI "\fBEntityId_t\fP \fBm_trustedWriterEntityId\fP"
.br
.RI "Trusted writer (for Builtin) "
.ti -1c
.RI "bool \fBm_expectsInlineQos\fP"
.br
.RI "Expects Inline Qos\&. "
.ti -1c
.RI "FragmentedChangePitStop * \fBfragmentedChangePitStop_\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBReaderHistory\fP"
.br
.ti -1c
.RI "class \fBRTPSParticipantImpl\fP"
.br
.ti -1c
.RI "class \fBMessageReceiver\fP"
.br
.ti -1c
.RI "class \fBEDP\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class \fBRTPSReader\fP, manages the reception of data from its matched writers\&. 
.SH "Member Function Documentation"
.PP 
.SS "RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::acceptMsgDirectedTo (\fBEntityId_t\fP & entityId)"
Returns true if the reader accepts a message directed to entityId\&. 
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::change_removed_by_history (\fBCacheChange_t\fP * change, \fBWriterProxy\fP * prox = \fCnullptr\fP)\fC [pure virtual]\fP"
Method to indicate the reader that some change has been removed due to HistoryQos requirements\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.br
\fIprox\fP Pointer to the \fBWriterProxy\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly removed\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::expectsInlineQos ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
True if the reader expects Inline QOS\&. 
.RE
.PP

.SS "\fBCacheChange_t\fP* eprosima::fastrtps::rtps::RTPSReader::findCacheInFragmentedCachePitStop (const \fBSequenceNumber_t\fP & sequence_number, const \fBGUID_t\fP & writer_guid)"

.PP
Search if there is a \fBCacheChange_t\fP, giving \fBSequenceNumber_t\fP and writer \fBGUID_t\fP, waiting to be completed because it is fragmented\&. 
.PP
\fBParameters\fP
.RS 4
\fIsequence_number\fP \fBSequenceNumber_t\fP of the searched \fBCacheChange_t\fP\&. 
.br
\fIwriter_guid\fP writer \fBGUID_t\fP of the searched \fBCacheChange_t\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
If a \fBCacheChange_t\fP was found, it will be returned\&. In other case nullptr is returned\&. 
.RE
.PP

.SS "RTPS_DllAPI \fBReaderListener\fP* eprosima::fastrtps::rtps::RTPSReader::getListener ()"
Get the associated listener, secondary attached Listener in case it is of coumpound type 
.PP
\fBReturns\fP
.RS 4
Pointer to the associated reader listener\&. 
.RE
.PP

.SS "virtual bool eprosima::fastrtps::rtps::RTPSReader::isInCleanState () const\fC [pure virtual]\fP"

.PP
Returns there is a clean state with all Writers\&. It occurs when the Reader received all samples sent by Writers\&. In other words, its WriterProxies are up to date\&. 
.PP
\fBReturns\fP
.RS 4
There is a clean state with all Writers\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::matched_writer_add (\fBRemoteWriterAttributes\fP & wdata)\fC [pure virtual]\fP"
Add a matched writer represented by its attributes\&. 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Attributes of the writer to add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly added\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::matched_writer_is_matched (\fBRemoteWriterAttributes\fP & wdata)\fC [pure virtual]\fP"
Tells us if a specific Writer is matched against this reader 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Pointer to the \fBWriterProxyData\fP object 
.RE
.PP
\fBReturns\fP
.RS 4
True if it is matched\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::matched_writer_remove (\fBRemoteWriterAttributes\fP & wdata)\fC [pure virtual]\fP"
Remove a writer represented by its attributes from the matched writers\&. 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Attributes of the writer to remove\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly removed\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::nextUnreadCache (\fBCacheChange_t\fP ** change, \fBWriterProxy\fP ** wp)\fC [pure virtual]\fP"
Read the next unread \fBCacheChange_t\fP from the history 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP POinter to pointer of \fBCacheChange_t\fP 
.br
\fIwp\fP Pointer to pointer to the \fBWriterProxy\fP 
.RE
.PP
\fBReturns\fP
.RS 4
True if read\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::nextUntakenCache (\fBCacheChange_t\fP ** change, \fBWriterProxy\fP ** wp)\fC [pure virtual]\fP"
Get the next \fBCacheChange_t\fP from the history to take\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to pointer of \fBCacheChange_t\fP\&. 
.br
\fIwp\fP Pointer to pointer to the \fBWriterProxy\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if read\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::processDataFragMsg (\fBCacheChange_t\fP * change, uint32_t sampleSize, uint32_t fragmentStartingNum)\fC [pure virtual]\fP"
Processes a new DATA FRAG message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&.
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.br
\fIsampleSize\fP Size of the complete, assembled message\&. 
.br
\fIfragmentStartingNum\fP Starting number of this particular fragment\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the reader accepts message\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::processDataMsg (\fBCacheChange_t\fP * change)\fC [pure virtual]\fP"
Processes a new DATA message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&.
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the reader accepts messages from the\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "virtual RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::processHeartbeatMsg (\fBGUID_t\fP & writerGUID, uint32_t hbCount, \fBSequenceNumber_t\fP & firstSN, \fBSequenceNumber_t\fP & lastSN, bool finalFlag, bool livelinessFlag)\fC [pure virtual]\fP"
Processes a new HEARTBEAT message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&.
.PP
\fBReturns\fP
.RS 4
true if the reader accepts messages from the\&. 
.RE
.PP

.PP
Implemented in \fBeprosima::fastrtps::rtps::StatelessReader\fP, and \fBeprosima::fastrtps::rtps::StatefulReader\fP\&.
.SS "RTPS_DllAPI void eprosima::fastrtps::rtps::RTPSReader::releaseCache (\fBCacheChange_t\fP * change)"
Release a cacheChange\&. 
.SS "RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::reserveCache (\fBCacheChange_t\fP ** change, uint32_t dataCdrSerializedSize)"
Reserve a \fBCacheChange_t\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to pointer to the Cache\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly reserved\&. 
.RE
.PP

.SS "RTPS_DllAPI bool eprosima::fastrtps::rtps::RTPSReader::setListener (\fBReaderListener\fP * target)"
Switch the \fBReaderListener\fP kind for the Reader\&. If the \fBRTPSReader\fP does not belong to the built-in protocols it switches out the old one\&. If it belongs to the built-in protocols, it sets the new \fBReaderListener\fP callbacks to be called after the built-in \fBReaderListener\fP ones\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP Pointed to ReaderLister to attach 
.RE
.PP
\fBReturns\fP
.RS 4
True is correctly set\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Cyber-Cmake from the source code\&.
