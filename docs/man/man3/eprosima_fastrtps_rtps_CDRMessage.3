.TH "eprosima::fastrtps::rtps::CDRMessage" 3 "Sun Sep 3 2023" "Version 8.0" "Cyber-Cmake" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eprosima::fastrtps::rtps::CDRMessage
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBinitCDRMsg\fP (\fBCDRMessage_t\fP *msg, uint32_t data_size=RTPSMESSAGE_COMMON_DATA_PAYLOAD_SIZE)"
.br
.ti -1c
.RI "bool \fBwrapVector\fP (\fBCDRMessage_t\fP *msg, std::vector< octet > &vectorToWrap)"
.br
.ti -1c
.RI "bool \fBappendMsg\fP (\fBCDRMessage_t\fP *first, \fBCDRMessage_t\fP *second)"
.br
.ti -1c
.RI "bool \fBaddProperty\fP (\fBCDRMessage_t\fP *msg, const \fBProperty\fP &property)"
.br
.ti -1c
.RI "bool \fBaddBinaryProperty\fP (\fBCDRMessage_t\fP *msg, const \fBBinaryProperty\fP &binary_property)"
.br
.ti -1c
.RI "bool \fBaddPropertySeq\fP (\fBCDRMessage_t\fP *msg, const PropertySeq &properties)"
.br
.ti -1c
.RI "bool \fBaddBinaryPropertySeq\fP (\fBCDRMessage_t\fP *msg, const BinaryPropertySeq &binary_properties)"
.br
.ti -1c
.RI "bool \fBaddBinaryPropertySeq\fP (\fBCDRMessage_t\fP *msg, const BinaryPropertySeq &binary_properties, const std::string &property_limit)"
.br
.ti -1c
.RI "bool \fBaddDataHolder\fP (\fBCDRMessage_t\fP *msg, const \fBDataHolder\fP &data_holder)"
.br
.ti -1c
.RI "bool \fBaddDataHolderSeq\fP (\fBCDRMessage_t\fP *msg, const DataHolderSeq &data_holders)"
.br
.ti -1c
.RI "bool \fBaddMessageIdentity\fP (\fBCDRMessage_t\fP *msg, const ::\fBsecurity::MessageIdentity\fP &message_identity)"
.br
.ti -1c
.RI "bool \fBaddParticipantGenericMessage\fP (\fBCDRMessage_t\fP *msg, const ::\fBsecurity::ParticipantGenericMessage\fP &message)"
.br
.in -1c
.PP
.RI "\fBRead from a CDRMessage_t\&.\fP"
.br
Methods to read different data types from a CDR message\&. Pointers to the message and to the data types are provided\&. The read position is updated in the message\&. It fails if you attempt to read outside the boundaries of the message\&. 
.PP
\fBParameters\fP
.RS 4
\fImsg\fP Pointer to message\&. 
.br
\fIdata_ptr\fP Pointer to data\&. 
.br
\fIsize\fP Number of bytes (if necessary)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "bool \fBreadEntityId\fP (\fBCDRMessage_t\fP *msg, const \fBEntityId_t\fP *id)"
.br
.ti -1c
.RI "bool \fBreadData\fP (\fBCDRMessage_t\fP *msg, octet *o, uint32_t length)"
.br
.ti -1c
.RI "bool \fBreadDataReversed\fP (\fBCDRMessage_t\fP *msg, octet *o, uint32_t length)"
.br
.ti -1c
.RI "bool \fBreadInt32\fP (\fBCDRMessage_t\fP *msg, int32_t *lo)"
.br
.ti -1c
.RI "bool \fBreadUInt32\fP (\fBCDRMessage_t\fP *msg, uint32_t *ulo)"
.br
.ti -1c
.RI "bool \fBreadInt64\fP (\fBCDRMessage_t\fP *msg, int64_t *lolo)"
.br
.ti -1c
.RI "bool \fBreadSequenceNumber\fP (\fBCDRMessage_t\fP *msg, \fBSequenceNumber_t\fP *sn)"
.br
.ti -1c
.RI "bool \fBreadInt16\fP (\fBCDRMessage_t\fP *msg, int16_t *i16)"
.br
.ti -1c
.RI "bool \fBreadUInt16\fP (\fBCDRMessage_t\fP *msg, uint16_t *i16)"
.br
.ti -1c
.RI "bool \fBreadLocator\fP (\fBCDRMessage_t\fP *msg, \fBLocator_t\fP *loc)"
.br
.ti -1c
.RI "bool \fBreadOctet\fP (\fBCDRMessage_t\fP *msg, octet *o)"
.br
.ti -1c
.RI "bool \fBreadSequenceNumberSet\fP (\fBCDRMessage_t\fP *msg, \fBSequenceNumberSet_t\fP *snset)"
.br
.ti -1c
.RI "bool \fBreadFragmentNumberSet\fP (\fBCDRMessage_t\fP *msg, \fBFragmentNumberSet_t\fP *snset)"
.br
.ti -1c
.RI "bool \fBreadTimestamp\fP (\fBCDRMessage_t\fP *msg, \fBTime_t\fP *ts)"
.br
.ti -1c
.RI "bool \fBreadString\fP (\fBCDRMessage_t\fP *msg, std::string *p_str)"
.br
.ti -1c
.RI "bool \fBreadOctetVector\fP (\fBCDRMessage_t\fP *msg, std::vector< octet > *ocvec)"
.br
.ti -1c
.RI "bool \fBreadProperty\fP (\fBCDRMessage_t\fP *msg, \fBProperty\fP &property)"
.br
.ti -1c
.RI "bool \fBreadBinaryProperty\fP (\fBCDRMessage_t\fP *msg, \fBBinaryProperty\fP &binary_property)"
.br
.ti -1c
.RI "bool \fBreadPropertySeq\fP (\fBCDRMessage_t\fP *msg, PropertySeq &properties)"
.br
.ti -1c
.RI "bool \fBreadBinaryPropertySeq\fP (\fBCDRMessage_t\fP *msg, BinaryPropertySeq &binary_properties)"
.br
.ti -1c
.RI "bool \fBreadDataHolder\fP (\fBCDRMessage_t\fP *msg, \fBDataHolder\fP &data_holder)"
.br
.ti -1c
.RI "bool \fBreadDataHolderSeq\fP (\fBCDRMessage_t\fP *msg, DataHolderSeq &data_holders)"
.br
.ti -1c
.RI "bool \fBreadMessageIdentity\fP (\fBCDRMessage_t\fP *msg, ::\fBsecurity::MessageIdentity\fP &message_identity)"
.br
.ti -1c
.RI "bool \fBreadParticipantGenericMessage\fP (\fBCDRMessage_t\fP *msg, ::\fBsecurity::ParticipantGenericMessage\fP &message)"
.br
.in -1c
.in -1c
.PP
.RI "\fBAdd to a CDRMessage_t\&.\fP"
.br
Methods to add different data types to a CDR message\&. Pointers to the message and to the data types are provided\&. The write position is updated in the message\&. It fails if you attempt to write outside the boundaries of the message\&. 
.PP
\fBParameters\fP
.RS 4
\fIPointer\fP to message\&. 
.br
\fIdata\fP Data to add (might be a pointer)\&. 
.br
\fIbyteSize\fP Number of bytes (if necessary)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "bool \fBaddData\fP (\fBCDRMessage_t\fP *, const octet *, const uint32_t number_bytes)"
.br
.ti -1c
.RI "bool \fBaddDataReversed\fP (\fBCDRMessage_t\fP *, const octet *, const uint32_t byte_number)"
.br
.ti -1c
.RI "bool \fBaddOctet\fP (\fBCDRMessage_t\fP *msg, octet o)"
.br
.ti -1c
.RI "bool \fBaddUInt16\fP (\fBCDRMessage_t\fP *msg, uint16_t us)"
.br
.ti -1c
.RI "bool \fBaddInt32\fP (\fBCDRMessage_t\fP *msg, int32_t lo)"
.br
.ti -1c
.RI "bool \fBaddUInt32\fP (\fBCDRMessage_t\fP *msg, uint32_t lo)"
.br
.ti -1c
.RI "bool \fBaddInt64\fP (\fBCDRMessage_t\fP *msg, int64_t lo)"
.br
.ti -1c
.RI "bool \fBaddEntityId\fP (\fBCDRMessage_t\fP *msg, const \fBEntityId_t\fP *id)"
.br
.ti -1c
.RI "bool \fBaddSequenceNumber\fP (\fBCDRMessage_t\fP *msg, const \fBSequenceNumber_t\fP *sn)"
.br
.ti -1c
.RI "bool \fBaddSequenceNumberSet\fP (\fBCDRMessage_t\fP *msg, const \fBSequenceNumberSet_t\fP *sns)"
.br
.ti -1c
.RI "bool \fBaddFragmentNumberSet\fP (\fBCDRMessage_t\fP *msg, \fBFragmentNumberSet_t\fP *fns)"
.br
.ti -1c
.RI "bool \fBaddLocator\fP (\fBCDRMessage_t\fP *msg, \fBLocator_t\fP *loc)"
.br
.ti -1c
.RI "bool \fBaddParameterStatus\fP (\fBCDRMessage_t\fP *msg, octet status)"
.br
.ti -1c
.RI "bool \fBaddParameterKey\fP (\fBCDRMessage_t\fP *msg, const \fBInstanceHandle_t\fP *iHandle)"
.br
.ti -1c
.RI "bool \fBaddParameterSentinel\fP (\fBCDRMessage_t\fP *msg)"
.br
.ti -1c
.RI "bool \fBaddParameterId\fP (\fBCDRMessage_t\fP *msg, ParameterId_t pid)"
.br
.ti -1c
.RI "bool \fBaddString\fP (\fBCDRMessage_t\fP *msg, const std::string &in_str)"
.br
.ti -1c
.RI "bool \fBaddOctetVector\fP (\fBCDRMessage_t\fP *msg, const std::vector< octet > *ocvec)"
.br
.ti -1c
.RI "bool \fBaddParameterSampleIdentity\fP (\fBCDRMessage_t\fP *msg, const \fBSampleIdentity\fP &sample_id)"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 
Namespace \fBCDRMessage\fP, contains inline methods to initialize \fBCDRMessage_t\fP and add or read different data types\&. 
.SH "Function Documentation"
.PP 
.SS "bool eprosima::fastrtps::rtps::CDRMessage::appendMsg (\fBCDRMessage_t\fP * first, \fBCDRMessage_t\fP * second)\fC [inline]\fP"
Append given \fBCDRMessage\fP to existing CDR Message\&. Joins two messages into the first one if it has space\&. 
.PP
\fBParameters\fP
.RS 4
\fIfirst\fP Pointer to first message\&. 
.br
\fIsecond\fP Pointer to second message\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::CDRMessage::initCDRMsg (\fBCDRMessage_t\fP * msg, uint32_t data_size = \fCRTPSMESSAGE_COMMON_DATA_PAYLOAD_SIZE\fP)\fC [inline]\fP"
Initialize given CDR message with default size\&. It frees the memory already allocated and reserves new one\&. 
.PP
\fBParameters\fP
.RS 4
\fImsg\fP Pointer to the message to initialize\&. 
.br
\fIdata_size\fP Size of the data the message is suppose to carry 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Cyber-Cmake from the source code\&.
