.TH "eprosima::fastrtps::rtps::StatefulReader" 3 "Sun Sep 3 2023" "Version 8.0" "Cyber-Cmake" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eprosima::fastrtps::rtps::StatefulReader
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <StatefulReader\&.h>\fP
.PP
Inherits \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBmatched_writer_add\fP (\fBRemoteWriterAttributes\fP &wdata)"
.br
.ti -1c
.RI "bool \fBmatched_writer_remove\fP (\fBRemoteWriterAttributes\fP &wdata, bool deleteWP)"
.br
.ti -1c
.RI "bool \fBmatched_writer_remove\fP (\fBRemoteWriterAttributes\fP &wdata)"
.br
.ti -1c
.RI "bool \fBmatched_writer_is_matched\fP (\fBRemoteWriterAttributes\fP &wdata)"
.br
.ti -1c
.RI "bool \fBmatched_writer_lookup\fP (const \fBGUID_t\fP &writerGUID, \fBWriterProxy\fP **WP)"
.br
.ti -1c
.RI "bool \fBprocessDataMsg\fP (\fBCacheChange_t\fP *change)"
.br
.ti -1c
.RI "bool \fBprocessDataFragMsg\fP (\fBCacheChange_t\fP *change, uint32_t sampleSize, uint32_t fragmentStartingNum)"
.br
.ti -1c
.RI "bool \fBprocessHeartbeatMsg\fP (\fBGUID_t\fP &writerGUID, uint32_t hbCount, \fBSequenceNumber_t\fP &firstSN, \fBSequenceNumber_t\fP &lastSN, bool finalFlag, bool livelinessFlag)"
.br
.ti -1c
.RI "bool \fBprocessGapMsg\fP (\fBGUID_t\fP &writerGUID, \fBSequenceNumber_t\fP &gapStart, \fBSequenceNumberSet_t\fP &gapList)"
.br
.ti -1c
.RI "bool \fBchange_removed_by_history\fP (\fBCacheChange_t\fP *change, \fBWriterProxy\fP *prox=nullptr)"
.br
.ti -1c
.RI "bool \fBchange_received\fP (\fBCacheChange_t\fP *a_change, \fBWriterProxy\fP *prox, std::unique_lock< std::recursive_mutex > &lock)"
.br
.ti -1c
.RI "RTPSParticipantImpl * \fBgetRTPSParticipant\fP () const"
.br
.ti -1c
.RI "bool \fBnextUnreadCache\fP (\fBCacheChange_t\fP **change, \fBWriterProxy\fP **wpout=nullptr)"
.br
.ti -1c
.RI "bool \fBnextUntakenCache\fP (\fBCacheChange_t\fP **change, \fBWriterProxy\fP **wpout=nullptr)"
.br
.ti -1c
.RI "bool \fBupdateTimes\fP (\fBReaderTimes\fP &times)"
.br
.ti -1c
.RI "\fBReaderTimes\fP & \fBgetTimes\fP ()"
.br
.ti -1c
.RI "size_t \fBgetMatchedWritersSize\fP () const"
.br
.ti -1c
.RI "void \fBsendFragAck\fP (\fBWriterProxy\fP *mp_WP, \fBCacheChange_t\fP *cit)"
.br
.ti -1c
.RI "bool \fBisInCleanState\fP () const"
.br
.RI "Returns there is a clean state with all Writers\&. It occurs when the Reader received all samples sent by Writers\&. In other words, its WriterProxies are up to date\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBRTPSParticipantImpl\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Class \fBStatefulReader\fP, specialization of \fBRTPSReader\fP than stores the state of the matched writers\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool eprosima::fastrtps::rtps::StatefulReader::change_received (\fBCacheChange_t\fP * a_change, \fBWriterProxy\fP * prox, std::unique_lock< std::recursive_mutex > & lock)"
This method is called when a new change is received\&. This method calls the received_change of the \fBHistory\fP and depending on the implementation performs different actions\&. 
.PP
\fBParameters\fP
.RS 4
\fIa_change\fP Pointer of the change to add\&. 
.br
\fIprox\fP Pointer to the \fBWriterProxy\fP that adds the Change\&. 
.br
\fIlock\fP mutex protecting the \fBStatefulReader\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if added\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::StatefulReader::change_removed_by_history (\fBCacheChange_t\fP * change, \fBWriterProxy\fP * prox = \fCnullptr\fP)\fC [virtual]\fP"
Method to indicate the reader that some change has been removed due to HistoryQos requirements\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.br
\fIprox\fP Pointer to the \fBWriterProxy\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly removed\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "size_t eprosima::fastrtps::rtps::StatefulReader::getMatchedWritersSize () const\fC [inline]\fP"
Get the number of matched writers 
.PP
\fBReturns\fP
.RS 4
Number of matched writers 
.RE
.PP

.SS "RTPSParticipantImpl* eprosima::fastrtps::rtps::StatefulReader::getRTPSParticipant () const\fC [inline]\fP"
Get the RTPS participant 
.PP
\fBReturns\fP
.RS 4
Associated RTPS participant 
.RE
.PP

.SS "\fBReaderTimes\fP& eprosima::fastrtps::rtps::StatefulReader::getTimes ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
Reference to the \fBReaderTimes\fP\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::StatefulReader::isInCleanState () const\fC [virtual]\fP"

.PP
Returns there is a clean state with all Writers\&. It occurs when the Reader received all samples sent by Writers\&. In other words, its WriterProxies are up to date\&. 
.PP
\fBReturns\fP
.RS 4
There is a clean state with all Writers\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::matched_writer_add (\fBRemoteWriterAttributes\fP & wdata)\fC [virtual]\fP"
Add a matched writer represented by a \fBWriterProxyData\fP object\&. 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Pointer to the WPD object to add\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly added\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::matched_writer_is_matched (\fBRemoteWriterAttributes\fP & wdata)\fC [virtual]\fP"
Tells us if a specific Writer is matched against this reader 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Pointer to the \fBWriterProxyData\fP object 
.RE
.PP
\fBReturns\fP
.RS 4
True if it is matched\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::matched_writer_lookup (const \fBGUID_t\fP & writerGUID, \fBWriterProxy\fP ** WP)"
Look for a specific \fBWriterProxy\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIwriterGUID\fP \fBGUID_t\fP of the writer we are looking for\&. 
.br
\fIWP\fP Pointer to pointer to a \fBWriterProxy\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if found\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::StatefulReader::matched_writer_remove (\fBRemoteWriterAttributes\fP & wdata)\fC [virtual]\fP"
Remove a \fBWriterProxyData\fP from the matached writers\&. 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Pointer to the WPD object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::matched_writer_remove (\fBRemoteWriterAttributes\fP & wdata, bool deleteWP)"
Remove a \fBWriterProxyData\fP from the matached writers\&. 
.PP
\fBParameters\fP
.RS 4
\fIwdata\fP Pointer to the WPD object\&. 
.br
\fIdeleteWP\fP If the Reader has to delete the associated WP object or not\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correct\&. 
.RE
.PP

.SS "bool eprosima::fastrtps::rtps::StatefulReader::nextUnreadCache (\fBCacheChange_t\fP ** change, \fBWriterProxy\fP ** wpout = \fCnullptr\fP)\fC [virtual]\fP"
Read the next unread \fBCacheChange_t\fP from the history 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to pointer of \fBCacheChange_t\fP 
.br
\fIwpout\fP Pointer to pointer the matched writer proxy 
.RE
.PP
\fBReturns\fP
.RS 4
True if read\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::nextUntakenCache (\fBCacheChange_t\fP ** change, \fBWriterProxy\fP ** wpout = \fCnullptr\fP)\fC [virtual]\fP"
Take the next \fBCacheChange_t\fP from the history; 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to pointer of \fBCacheChange_t\fP 
.br
\fIwpout\fP Pointer to pointer the matched writer proxy 
.RE
.PP
\fBReturns\fP
.RS 4
True if read\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::processDataFragMsg (\fBCacheChange_t\fP * change, uint32_t sampleSize, uint32_t fragmentStartingNum)\fC [virtual]\fP"
Processes a new DATA FRAG message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.br
\fIsampleSize\fP Size of the complete assembled message\&. 
.br
\fIfragmentStartingNum\fP fragment number of this particular fragment\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the reader accepts messages\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::processDataMsg (\fBCacheChange_t\fP * change)\fC [virtual]\fP"
Processes a new DATA message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&. 
.PP
\fBParameters\fP
.RS 4
\fIchange\fP Pointer to the \fBCacheChange_t\fP\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the reader accepts messages\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::processHeartbeatMsg (\fBGUID_t\fP & writerGUID, uint32_t hbCount, \fBSequenceNumber_t\fP & firstSN, \fBSequenceNumber_t\fP & lastSN, bool finalFlag, bool livelinessFlag)\fC [virtual]\fP"
Processes a new HEARTBEAT message\&. Previously the message must have been accepted by function acceptMsgDirectedTo\&.
.PP
\fBReturns\fP
.RS 4
true if the reader accepts messages\&. 
.RE
.PP

.PP
Implements \fBeprosima::fastrtps::rtps::RTPSReader\fP\&.
.SS "bool eprosima::fastrtps::rtps::StatefulReader::updateTimes (\fBReaderTimes\fP & times)"
Update the times parameters of the Reader\&. 
.PP
\fBParameters\fP
.RS 4
\fItimes\fP \fBReaderTimes\fP reference\&. 
.RE
.PP
\fBReturns\fP
.RS 4
True if correctly updated\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Cyber-Cmake from the source code\&.
