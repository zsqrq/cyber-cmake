.TH "md_cyber_doxy_docs_source_CyberRT_Migration_Guide" 3 "Sun Sep 3 2023" "Version 8.0" "Cyber-Cmake" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_cyber_doxy_docs_source_CyberRT_Migration_Guide \- Migration guide from Apollo ROS 
This article describes the essential changes for projects to migrate from Apollo ROS (Apollo 3\&.0 and before) to Apollo Cyber RT (Apollo 3\&.5 and after)\&. We will be using the very first ROS project talker/listener as example to demonstrate step by step migration instruction\&.
.SH "Build system"
.PP
ROS use \fCCMake\fP as its build system but Cyber RT use \fCbazel\fP\&. In a ROS project, CmakeLists\&.txt and package\&.xml are required for defining build configs like build target, dependency, message files and so on\&. As for a Cyber RT component, a single bazel BUILD file covers\&. Some key build config mappings are listed below\&.
.PP
Cmake
.PP
.PP
.nf
project(pb_msgs_example)
add_proto_files(
  DIRECTORY proto
  FILES chatter\&.proto
)
## Declare a C++ executable
add_executable(pb_talker src/talker\&.cpp)
target_link_libraries(pb_talker ${catkin_LIBRARIES}pb_msgs_example_proto)
add_executable(pb_listener src/listener\&.cpp)
target_link_libraries(pb_listener ${catkin_LIBRARIES}  pb_msgs_example_proto)
.fi
.PP
.PP
Bazel
.PP
.PP
.nf
cc_binary(
  name = "talker",
  srcs = ["talker\&.cc"],
  deps = [
    "//cyber",
    "//cyber/examples/proto:examples_cc_proto",
    ],
  )
cc_binary(
  name = "listener",
  srcs = ["listener\&.cc"],
  deps = [
    "//cyber",
    "//cyber/examples/proto:examples_cc_proto",
    ],
  )
.fi
.PP
.PP
We can find the mapping easily from the 2 file snippets\&. For example, \fCpb_talker\fP and \fCsrc/talker\&.cpp\fP in cmake \fCadd_executable\fP setting map to \fCname = 'talker'\fP and \fCsrcs = ['talker\&.cc']\fP in BUILD file \fCcc_binary\fP\&.
.SS "Proto"
Apollo ROS has customized to support proto message formate that a separate section \fCadd_proto_files\fP and projectName_proto(\fCpb_msgs_example_proto\fP) in \fCtarget_link_libraries\fP are required to send message in proto formate\&. For config proto message in Cyber RT, it's as simple as adding the target proto file path concantenated with name of \fCcc_proto_library\fP in \fCdeps\fP setting\&. The \fCcc_proto_library\fP is set up in BUILD file under proto folder\&.
.PP
.PP
.nf
cc_proto_library(
  name = "examples_cc_proto",
  deps = [
    ":examples_proto",
  ],
)
proto_library(
  name = "examples_proto",
  srcs = [
    "examples\&.proto",
  ],
)
.fi
.PP
.PP
The package definition has also changed in Cyber RT\&. In Apollo ROS a fixed package \fCpackage pb_msgs;\fP is used for proto files, but in Cyber RT, the proto file path \fCpackage apollo\&.cyber\&.examples\&.proto;\fP is used instead\&.
.SH "Folder structure"
.PP
As shown below, Cyber RT remove the src folder and pull all source code in the same folder as BUILD file\&. BUILD file plays the same role as CMakeLists\&.txt plus package\&.xml\&. Both Cyber RT and Apollo ROS talker/listener example have a proto folder for message proto files but Cyber RT requires a separate BUILD file for proto folder to set up the proto library\&.
.SS "Apollo ROS"
.IP "\(bu" 2
CMakeLists\&.txt
.IP "\(bu" 2
package\&.xml
.IP "\(bu" 2
proto
.IP "  \(bu" 4
chatter\&.proto
.PP

.IP "\(bu" 2
src
.IP "  \(bu" 4
listener\&.cpp
.IP "  \(bu" 4
talker\&.cpp
.PP

.PP
.SS "Cyber RT"
.IP "\(bu" 2
BUILD
.IP "\(bu" 2
listener\&.cc
.IP "\(bu" 2
talker\&.cc
.IP "\(bu" 2
proto
.IP "  \(bu" 4
BUILD
.IP "  \(bu" 4
examples\&.proto (with chatter message)
.PP

.PP
.SH "Update source code"
.PP
.SS "Listener"
Cyber RT
.PP
.PP
.nf
#include "cyber/cyber\&.h"
#include "cyber/examples/proto/examples\&.pb\&.h"

void MessageCallback(
    const std::shared_ptr<apollo::cyber::examples::proto::Chatter>& msg) {
  AINFO << "Received message seq-> " << msg->seq();
  AINFO << "msgcontent->" << msg->content();
}

int main(int argc, char* argv[]) {
  // init cyber framework
  apollo::cyber::Init(argv[0]);
  // create listener node
  auto listener_node = apollo::cyber::CreateNode("listener");
  // create listener
  auto listener =
      listener_node->CreateReader<apollo::cyber::examples::proto::Chatter>(
          "channel/chatter", MessageCallback);
  apollo::cyber::WaitForShutdown();
  return 0;
}
.fi
.PP
.PP
ROS
.PP
.PP
.nf
#include "ros/ros\&.h"
#include "chatter\&.pb\&.h"

void MessageCallback(const boost::shared_ptr<pb_msgs::Chatter>& msg) {
  ROS_INFO_STREAM("Time: " << msg->stamp()\&.sec() << "\&." << msg->stamp()\&.nsec());
  ROS_INFO("I heard pb Chatter message: [%s]", msg->content()\&.c_str());
}

int main(int argc, char** argv) {
  ros::init(argc, argv, "listener");
  ros::NodeHandle n;
  ros::Subscriber pb_sub = n\&.subscribe("chatter", 1000, MessageCallback);
  ros::spin();
  return 0;
}
.fi
.PP
.PP
You can see easily from the two listener code above that Cyber RT provides very similar API to for developers to migrate from ROS\&.
.PP
.IP "\(bu" 2
\fCros::init(argc, argv, 'listener');\fP --> \fCapollo::cyber::Init(argv[0]);\fP
.IP "\(bu" 2
\fCros::NodeHandle n;\fP --> \fCauto listener_node = apollo::cyber::CreateNode('listener');\fP
.IP "\(bu" 2
\fCros::Subscriber pb_sub = n\&.subscribe('chatter', 1000, MessageCallback);\fP --> \fCauto listener = listener_node->CreateReader('channel/chatter', MessageCallback);\fP
.IP "\(bu" 2
\fCros::spin();\fP --> \fCapollo::cyber::WaitForShutdown();\fP
.PP
.PP
Note: for Cyber RT, a listener node has to use \fCnode->CreateReader<messageType>(channelName, callback)\fP to read data from channel\&.
.SS "Talker"
Cyber RT
.PP
.PP
.nf
#include "cyber/cyber\&.h"
#include "cyber/examples/proto/examples\&.pb\&.h"

using apollo::cyber::examples::proto::Chatter;

int main(int argc, char *argv[]) {
  // init cyber framework
  apollo::cyber::Init(argv[0]);
  // create talker node
  auto talker_node = apollo::cyber::CreateNode("talker");
  // create talker
  auto talker = talker_node->CreateWriter<Chatter>("channel/chatter");
  Rate rate(1\&.0);
  while (apollo::cyber::OK()) {
    static uint64_t seq = 0;
    auto msg = std::make_shared<Chatter>();
    msg->set_timestamp(Time::Now()\&.ToNanosecond());
    msg->set_lidar_timestamp(Time::Now()\&.ToNanosecond());
    msg->set_seq(seq++);
    msg->set_content("Hello, apollo!");
    talker->Write(msg);
    AINFO << "talker sent a message!";
    rate\&.Sleep();
  }
  return 0;
}
.fi
.PP
.PP
ROS
.PP
.PP
.nf
#include "ros/ros\&.h"
#include "chatter\&.pb\&.h"

#include <sstream>

int main(int argc, char** argv) {
  ros::init(argc, argv, "talker");
  ros::NodeHandle n;
  ros::Publisher chatter_pub = n\&.advertise<pb_msgs::Chatter>("chatter", 1000);
  ros::Rate loop_rate(10);
  int count = 0;
  while (ros::ok()) {
    pb_msgs::Chatter msg;
    ros::Time now = ros::Time::now();
    msg\&.mutable_stamp()->set_sec(now\&.sec);
    msg\&.mutable_stamp()->set_nsec(now\&.nsec);
    std::stringstream ss;
    ss << "Hello world " << count;
    msg\&.set_content(ss\&.str());
    chatter_pub\&.publish(msg);
    ros::spinOnce();
    loop_rate\&.sleep();
  }
  return 0;
}
.fi
.PP
.PP
Most of the mappings are illustrated in listener code above, the rest are listed here\&.
.PP
.IP "\(bu" 2
\fCros::Publisher chatter_pub = n\&.advertise<pb_msgs::Chatter>('chatter', 1000);\fP --> \fCauto talker = talker_node->CreateWriter<Chatter>('channel/chatter');\fP
.IP "\(bu" 2
\fCchatter_pub\&.publish(msg);\fP --> \fCtalker->Write(msg);\fP
.PP
.SH "Tools mapping"
.PP
ROS   Cyber RT   Note    rosbag   cyber_recorder   data file    scripts/diagnostics\&.sh   cyber_monitor   channel debug    offline_lidar_visualizer_tool   cyber_visualizer   point cloud visualizer   
.SH "ROS bag data migration"
.PP
The data file changed from ROS bag to Cyber record in Cyber RT\&. Cyber RT has a data migration tool \fCrosbag_to_record\fP for users to easily migrate data files before Apollo 3\&.0 (ROS) to Cyber RT like the sample usage below\&.
.PP
.PP
.nf
rosbag_to_record demo_3\&.0\&.bag demo_3\&.5\&.record
.fi
.PP
 
